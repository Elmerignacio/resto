"use strict";Object.defineProperty(exports, "__esModule", {value: true});// Generated file, do not edit! Run "yarn generate" to re-generate this file.
/* istanbul ignore file */
/**
 * Enum of all token types, with bit fields to signify meaningful properties.
 */
var TokenType; (function (TokenType) {
  // Precedence 0 means not an operator; otherwise it is a positive number up to 12.
  const PRECEDENCE_MASK = 0xf; TokenType[TokenType["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
  const IS_KEYWORD = 1 << 4; TokenType[TokenType["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
  const IS_ASSIGN = 1 << 5; TokenType[TokenType["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
  const IS_RIGHT_ASSOCIATIVE = 1 << 6; TokenType[TokenType["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
  const IS_PREFIX = 1 << 7; TokenType[TokenType["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
  const IS_POSTFIX = 1 << 8; TokenType[TokenType["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
  const IS_EXPRESSION_START = 1 << 9; TokenType[TokenType["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";

  const num = 512; TokenType[TokenType["num"] = num] = "num"; // num startsExpr
  const bigint = 1536; TokenType[TokenType["bigint"] = bigint] = "bigint"; // bigint startsExpr
  const decimal = 2560; TokenType[TokenType["decimal"] = decimal] = "decimal"; // decimal startsExpr
  const regexp = 3584; TokenType[TokenType["regexp"] = regexp] = "regexp"; // regexp startsExpr
  const string = 4608; TokenType[TokenType["string"] = string] = "string"; // string startsExpr
  const name = 5632; TokenType[TokenType["name"] = name] = "name"; // name startsExpr
  const eof = 6144; TokenType[TokenType["eof"] = eof] = "eof"; // eof
  const bracketL = 7680; TokenType[TokenType["bracketL"] = bracketL] = "bracketL"; // [ startsExpr
  const bracketR = 8192; TokenType[TokenType["bracketR"] = bracketR] = "bracketR"; // ]
  const braceL = 9728; TokenType[TokenType["braceL"] = braceL] = "braceL"; // { startsExpr
  const braceBarL = 10752; TokenType[TokenType["braceBarL"] = braceBarL] = "braceBarL"; // {| startsExpr
  const braceR = 11264; TokenType[TokenType["braceR"] = braceR] = "braceR"; // }
  const braceBarR = 12288; TokenType[TokenType["braceBarR"] = braceBarR] = "braceBarR"; // |}
  const parenL = 13824; TokenType[TokenType["parenL"] = parenL] = "parenL"; // ( startsExpr
  const parenR = 14336; TokenType[TokenType["parenR"] = parenR] = "parenR"; // )
  const comma = 15360; TokenType[TokenType["comma"] = comma] = "comma"; // ,
  const semi = 16384; TokenType[TokenType["semi"] = semi] = "semi"; // ;
  const colon = 17408; TokenType[TokenType["colon"] = colon] = "colon"; // :
  const doubleColon = 18432; TokenType[TokenType["doubleColon"] = doubleColon] = "doubleColon"; // ::
  const dot = 19456; TokenType[TokenType["dot"] = dot] = "dot"; // .
  const question = 20480; TokenType[TokenType["question"] = question] = "question"; // ?
  const questionDot = 21504; TokenType[TokenType["questionDot"] = questionDot] = "questionDot"; // ?.
  const arrow = 22528; TokenType[TokenType["arrow"] = arrow] = "arrow"; // =>
  const template = 23552; TokenType[TokenType["template"] = template] = "template"; // template
  const ellipsis = 24576; TokenType[TokenType["ellipsis"] = ellipsis] = "ellipsis"; // ...
  const backQuote = 25600; TokenType[TokenType["backQuote"] = backQuote] = "backQuote"; // `
  const dollarBraceL = 27136; TokenType[TokenType["dollarBraceL"] = dollarBraceL] = "dollarBraceL"; // ${ startsExpr
  const at = 27648; TokenType[TokenType["at"] = at] = "at"; // @
  const hash = 29184; TokenType[TokenType["hash"] = hash] = "hash"; // # startsExpr
  const eq = 29728; TokenType[TokenType["eq"] = eq] = "eq"; // = isAssign
  const assign = 30752; TokenType[TokenType["assign"] = assign] = "assign"; // _= isAssign
  const preIncDec = 32640; TokenType[TokenType["preIncDec"] = preIncDec] = "preIncDec"; // ++/-- prefix postfix startsExpr
  const postIncDec = 33664; TokenType[TokenType["postIncDec"] = postIncDec] = "postIncDec"; // ++/-- prefix postfial_guidance( maneuver )  
	filter_natural_guidance( nextManeuver )
	
	check_voice_guidance_settings()

	if ( string.lower(maneuver.ng_language) == string.lower(main_attribute_array.ngLangCode) ) and use_nguidance then
		maneuver.nguidance = nG_prepositions[maneuver.ng_preposition].." "..maneuver.ng_name
		nextManeuver.nguidance = nG_prepositions[nextManeuver.ng_preposition].." "..nextManeuver.ng_name
	else
		maneuver.nguidance = ""
		nextManeuver.nguidance = ""
	end

    if ( maneuver_set_count == 2 ) then	    
        double_command = true
    else
		double_command = false
    end

	dgttsp_rules()

end

function check_maneuver_table( maneuver )
	for k,v in pairs(base_maneuver_table) do
		if maneuver[ k ] == nil or maneuver[ k ] == "" then
			maneuver[ k ] = v
		end
	end
end

function cleanup( )
	distance_1 = ""			
	usedUnit_1 = ""			
	tts_street_1 = ""		
	tts_signpost_1 = ""		
	tts_street_2 = ""		
	tts_signpost_2 = ""		
	command_id_1 = ""		
	command_id_2 = ""		
	exit_no_roundabout = "" 
	head_orientation = ""	
	ped_turn_no = ""		
	exit_number = ""		
	waypoint_1 = ""
end

function expand_dgttsp(token, result_sentence)

	if trigger ~= "WEB" then
		function nocase (s)	
		  s = string.gsub(s, "%a", function (c)
				return string.format("[%s%s]", string.lower(c),
											   string.upper(c))
			  end)
		  return s
		end

		token, count = string.gsub( token, "\/", " !BREAK! " )	

		
		--token, count = string.gsub( token, "Xi%s([A-Z])", "/+'si/+ %1" )

		token = " "..token.." "

		token = lang_spec_abbr(token, result_sentence)

		for word, sign in string.gfind(token, "(%a+)([%p ])") do
			word2 = nil
			if sign ~= " " then
				word2 = word..sign
			end

			
			if abbr_cs[word] ~= nil then
				token, count = string.gsub( token, " "..word.." ", " "..abbr_cs[word].." " )
				if word2 ~= nil then
					token, count = string.gsub( token, " "..word2.." ", " "..abbr_cs[word].." " )
				end
			end

			expr1 = nocase(word)
			if word2 ~= nil then
				expr2 = expr1.."[\\"..sign.."]"
			end
			word = string.lower(word)

			
			if abbr_begin[word] ~= nil then
				token, count = string.gsub( token, "^ "..expr1.." ", abbr_begin[word].." " )
				if word2 ~= nil then
					token, count = string.gsub( token, "^ "..expr2.." ", abbr_begin[word].." " )
				end
			end

			
			if abbr_end[word] ~= nil then
				token, count = string.gsub( token, " "..expr1.." $", " "..abbr_end[word] )
				if word2 ~= nil then
					token, count = string.gsub( token, " "..expr2.." $", " "..abbr_end[word] )
				end
			end

			
			if abbr_misc[word] ~= nil then
				token, count = string.gsub( token, " "..expr1.." ", " "..abbr_misc[word].." " )
				if word2 ~= nil then
					token, count = string.gsub( token, " "..expr2.." ", " "..abbr_misc[word].." " )
				end
			end
		end
	end
	return token
end

function select_sentence_1( )

	result_id = {"0","0","0","0","0","0","0","0"}	

	if trigger == "ROUTE_RECALCULATION" and use_gpswarning then
		result_id = {"w","0","0","0","0","0","0","0"}	

	elseif ( trigger == "COMMAND" or trigger == "PEDESTRIAN_COMMAND" ) and maneuver.id == "END" then
		if maneuver.extra_string == "RIGHT" then
			result_id = {"y","p","0","0","0","0","0","0"}	
		elseif maneuver.extra_string == "LEFT" then
			result_id = {"y","q","0","0","0","0","0","0"}	
		else
			result_id = {"y","0","0","0","0","0","0","0"}	
		end

	elseif ( trigger == "COMMAND" or trigger == "PEDESTRIAN_COMMAND" ) and maneuver.id == "STOPOVER" then
		if maneuver.extra_string == "RIGHT" then
			result_id = {"z","r","0","0","0","0","0","0"}	
		elseif maneuver.extra_string == "LEFT" then
			result_id = {"z","s","0","0","0","0","0","0"}	
		else
			result_id = {"z","0","0","0","0","0","0","0"}	
		end

	elseif ( trigger == "PEDESTRIAN_COMMAND" and nonTTS ) then
		result_id = {"x","0","0","0","0","0","0","0"}	
		double_command = false

	elseif trigger == "WEB" and ( maneuver.id == "UNDEFINED" or maneuver.id == "HEAD_TO" ) then
		distance_1, usedUnit_1 = checkMultiPlurals( maneuver.dist_to_unit_string, unit_follow[ maneuver.dist_unit ], true )
		maneuver.id = "HEAD_TO"
		if maneuver.description ~= nil and maneuver.description ~= "" then
			set_result_id( 2 , "w" )
			waypoint_1 = maneuver.description
		end
		process_ped_1st_cmd( )

	elseif guidance_mode ~= "pedestrian" then
		process_car_1st_cmd( )	

	elseif not nonTTS then
		process_ped_1st_cmd( )	

	else
		double_command = false

	end

	filter_double_street_on_street_signpost_combination( )
	command_id_1 = result_id[1]..result_id[2]..result_id[3]..result_id[4]..result_id[5]..result_id[6]..result_id[7]..result_id[8]
	sentence_1 = set_result( command_id_1 )

	cleanup( )

end

function select_sentence_2( )

	result_id = {"0","0","0","0","0","0","0","0"}	

	if guidance_mode ~= "pedestrian" then
		process_car_2nd_cmd( maneuver, nextManeuver, use_dgttsp_0, use_dgttsp_1 )	

	else
		process_ped_2nd_cmd( nextManeuver )	

	end

	filter_double_street_on_street_signpost_combination( )
	command_id_2 = result_id[1]..result_id[2]..result_id[3]..result_id[4]..result_id[5]..result_id[6]..result_id[7]..result_id[8]
	sentence_2 = set_result( command_id_2 )

	cleanup( )

end

function process_car_1st_cmd( )

    if trigger == "GPS_SIGNAL_LOST" and use_gpswarning then
		result_id = {"p","0","0","0","0","0","0","0"}	

	elseif trigger == "GPS_SIGNAL_RESTORED" and use_gpswarning then
		result_id = {"q","0","0","0","0","0","0","0"}	

    elseif trigger == "SAFETYSPOT_WARNER" and use_safetyspotwarning then
        if above_speed_limit then
        	result_id = {"v","0","0","0","0","0","0","0"}	
        else
			result_id = {"x","0","0","0","0","0","0","0"}	
        end

    elseif trigger == "SPEED_WARNER" and use_speedwarning then
    	result_id = {"r","0","0","0","0","0","0","0"}	

    elseif trigger == "TRAFFIC_WARNER" and use_trafficwarning then
        if avoidance_mode == "AUTOMATIC_AVOIDANCE" then
        	result_id = {"s","0","0","0","0","0","0","0"}	
        elseif avoidance_mode == "MANUAL_AVOIDANCE" then
        	result_id = {"t","0","0","0","0","0","0","0"}	
        end

    elseif trigger == "TRAFFIC_DETOUR_FAILED" and use_trafficwarning then
    	result_id = {"u","0","0","0","0","0","0","0"}	

    
    elseif trigger == "COMMAND" then
        process_car_final_command( maneuver, use_dgttsp_0 )

    elseif trigger == "REMINDER1" or trigger == "REMINDER2" then
        process_car_reminders( maneuver, use_dgttsp_0 )

    elseif trigger == "ANNOUNCEMENT" or trigger == "WEB" then
        process_car_announcement( maneuver, use_dgttsp_0 )

	end

end

function process_car_2nd_cmd( firstManeuver, secondManeuver, useSignpost, useSignpostNext )

	if second_cmd_trigger == "1" then

		junction_turn, maneuver_command = get_maneuver( "car", secondManeuver )

		if secondManeuver.dist_to <= 30
		  and secondManeuver.id ~= "END"
		  and secondManeuver.id ~= "ROUNDABOUT"
		  and secondManeuver.id ~= "STOPOVER" then
			set_result_id( 1 , "j" )	
		else
			set_result_id( 1 , "h" )	
		end

		if secondManeuver.id == "JUNCTION" then

			if right[ secondManeuver.turn ] ~= nil and secondManeuver.exits_right == 1 then
				set_result_id( 4 , "y" )	
			elseif left[ secondManeuver.turn ] ~= nil and secondManeuver.exits_left == 1 then
				set_result_id( 4 , "z" )	
			else
				set_result_id( 4 , junction_turn )
			end

		else
			
			if highway[ secondManeuver.id ] ~= nil then
				if secondManeuver.turn ~= "UNDEFINED" then
					maneuver_command = nil
				end
			elseif secondManeuver.id == "ROUNDABOUT" or secondManeuver.id == "EXIT_ROUNDABOUT" then
				junction_turn = nil
			end
			if junction_turn ~= nil then
				set_result_id( 4 , junction_turn )
			end
			if maneuver_command ~= nil then
				set_result_id( 5 , maneuver_command )
			end
			if secondManeuver.id == "ROUNDABOUT" then
				roundabout_car( secondManeuver )
			end
		end
		if (secondManeuver.id == "ENTER_HIGHWAY" or secondManeuver.id == "ENTER_URBAN_HIGHWAY"
		 or secondManeuver.id == "ENTER_HIGHWAY_FROM_LEFT" or secondManeuver.id == "ENTER_URBAN_HIGHWAY_FROM_LEFT"
		  or secondManeuver.id == "ENTER_HIGHWAY_FROM_RIGHT" or secondManeuver.id == "ENTER_URBAN_HIGHWAY_FROM_RIGHT") and not nonTTS then
			tts_street_1, tts_signpost_1 = insert_signpost_enter_hwy( secondManeuver, useSignpostNext )
		elseif secondManeuver.id == "ROUNDABOUT" then
			add_route_after_roundabout( secondManeuver, useSignpostNext )
		elseif not nonTTS then
			tts_street_1 = add_street_name_or_route( secondManeuver, useSignpostNext )
		end

	elseif second_cmd_trigger == "2" then

		set_result_id( 1 , "h" )	
		junction_turn, maneuver_command = get_maneuver( "car", firstManeuver )
		set_result_id( 4 , maneuver_command )
		if not nonTTS then
			tts_street_1, tts_signpost_1 = insert_signpost_enter_hwy( firstManeuver, useSignpost )
		end

	elseif second_cmd_trigger == "3" then

		second_command_leave_or_continue_hwy( secondManeuver )

		if ( secondManeuver.signpost_direction == "" )
		  and ( firstManeuver.next_route ~= "" )
		  and ( secondManeuver.id ~= "END" and secondManeuver.id ~= "STOPOVER" ) and use_streetnames and use_signposts then
			set_result_id( 8 , "x" )	
			tts_street_2 = secondManeuver.next_route
			tts_signpost_2 = firstManeuver.signpost_direction
		elseif (( secondManeuver.signpost_direction ~= "" )
		  or ( secondManeuver.next_route ~= "" )) and ( secondManeuver.id ~= "END" and secondManeuver.id ~= "STOPOVER" ) and use_streetnames and use_signposts then
			set_result_id( 8 , "x" )	
			tts_street_2 = secondManeuver.next_route
			tts_signpost_2 = secondManeuver.signpost_direction
		end

	elseif second_cmd_trigger == "4" then

		second_command_leave_or_continue_hwy( secondManeuver )
		if use_streetnames and use_signposts then
			set_result_id( 8 , "x" )	
			tts_street_2 = firstManeuver.next_route
			tts_signpost_2 = firstManeuver.signpost_direction
		end

	elseif second_cmd_trigger == "5" then

		second_command_leave_or_continue_hwy( secondManeuver )

	end

end

function process_ped_1st_cmd( )
	
	if trigger == "PEDESTRIAN_ANNOUNCEMENT" or trigger == "WEB" then
        process_pedestrian_announcement( maneuver )

    elseif trigger == "PEDESTRIAN_COMMAND" then
        process_pedestrian_final_command( maneuver )
    end
end

function process_ped_2nd_cmd( secondManeuver )

	if second_cmd_trigger == "1" then
        junction_turn, maneuver_command = get_maneuver( "pedestrian", secondManeuver )
		distance_1, usedUnit_1 = include_distance ( secondManeuver, false )
        if secondManeuver.id == "ROUNDABOUT" then
            roundabout_pedestrian( secondManeuver )
        elseif junction_turn ~= nil and junction_turn ~= "0" then
			set_result_id( 3 , junction_turn )
        else
			set_result_id( 4 , maneuver_command )
        end
	end

end

function dgttsp_rules()
--------------------------------------------------------------------------

--------------------------------------------------------------------------

    if road_class == "STREET" then	

        if ( trigger == "ANNOUNCEMENT" and maneuver_1.dist_to <= 500 ) or trigger == "REMINDER1" then
            use_dgttsp_0 = true
            use_dgttsp_1 = false
        elseif trigger == "COMMAND" and double_command then
            use_dgttsp_0 = false
            use_dgttsp_1 = true
        else
            use_dgttsp_0 = false
            use_dgttsp_1 = false
        end

    else 							

        if ( trigger == "ANNOUNCEMENT" and  maneuver_1.dist_to <= 650  ) or trigger == "REMINDER1" then
            use_dgttsp_0 = true
            use_dgttsp_1 = false

        elseif trigger == "COMMAND" and double_command then
            use_dgttsp_0 = false
            use_dgttsp_1 = true
        else
            use_dgttsp_0 = false
            use_dgttsp_1 = false
        end

    end
    if trigger == "WEB" then
		use_dgttsp_0 = true
		use_dgttsp_1 = true
    end
    if nonTTS then
		use_dgttsp_0 = false
		use_dgttsp_1 = false
	end
end

function pro_while:
      return "while";
    case TokenType._with:
      return "with";
    case TokenType._new:
      return "new";
    case TokenType._this:
      return "this";
    case TokenType._super:
      return "super";
    case TokenType._class:
      return "class";
    case TokenType._extends:
      return "extends";
    case TokenType._export:
      return "export";
    case TokenType._import:
      return "import";
    case TokenType._yield:
      return "yield";
    case TokenType._null:
      return "null";
    case TokenType._true:
      return "true";
    case TokenType._false:
      return "false";
    case TokenType._in:
      return "in";
    case TokenType._instanceof:
      return "instanceof";
    case TokenType._typeof:
      return "typeof";
    case TokenType._void:
      return "void";
    case TokenType._delete:
      return "delete";
    case TokenType._async:
      return "async";
    case TokenType._get:
      return "get";
    case TokenType._set:
      return "set";
    case TokenType._declare:
      return "declare";
    case TokenType._readonly:
      return "readonly";
    case TokenType._abstract:
      return "abstract";
    case TokenType._static:
      return "static";
    case TokenType._public:
      return "public";
    case TokenType._private:
      return "private";
    case TokenType._protected:
      return "protected";
    case TokenType._override:
      return "override";
    case TokenType._as:
      return "as";
    case TokenType._enum:
      return "enum";
    case TokenType._type:
      return "type";
    case TokenType._implements:
      return "implements";
    default:
      return "";
  }
} exports.formatTokenType = formatTokenType;
