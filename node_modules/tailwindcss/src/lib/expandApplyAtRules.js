import postcss from 'postcss'
import parser from 'postcss-selector-parser'

import { resolveMatches } from './generateRules'
import escapeClassName from '../util/escapeClassName'
import { applyImportantSelector } from '../util/applyImportantSelector'
import { movePseudos } from '../util/pseudoElements'

/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */

function extractClasses(node) {
  /** @type {Map<string, Set<string>>} */
  let groups = new Map()

  let container = postcss.root({ nodes: [node.clone()] })

  container.walkRules((rule) => {
    parser((selectors) => {
      selectors.walkClasses((classSelector) => {
        let parentSelector = classSelector.parent.toString()

        let classes = groups.get(parentSelector)
        if (!classes) {
          groups.set(parentSelector, (classes = new Set()))
        }

        classes.add(classSelector.value)
      })
    }).processSync(rule.selector)
  })

  let normalizedGroups = Array.from(groups.values(), (classes) => Array.from(classes))
  let classes = normalizedGroups.flat()

  return Object.assign(classes, { groups: normalizedGroups })
}

let selectorExtractor = parser()

/**
 * @param {string} ruleSelectors
 */
function extractSelectors(ruleSelectors) {
  return selectorExtractor.astSync(ruleSelectors)
}

function extractBaseCandidates(candidates, separator) {
  let baseClasses = new Set()

  for (let candidate of candidates) {
    baseClasses.add(candidate.split(separator).pop())
  }

  return Array.from(baseClasses)
}

function prefix(context, selector) {
  let prefix = context.tailwindConfig.prefix
  return typeof prefix === 'function' ? prefix(selector) : prefix + selector
}

function* pathToRoot(node) {
  yield node
  while (node.parent) {
    yield node.parent
    node = node.parent
  }
}

/**
 * Only clone the node itself and not its children
 *
 * @param {*} node
 * @param {*} overrides
 * @returns
 */
function shallowClone(node, overrides = {}) {
  let children = node.nodes
  node.nodes = []

  let tmp = node.clone(overrides)

  node.nodes = children

  return tmp
}

/**
 * Clone just the nodes all the way to the top that are required to represent
 * this singular rule in the tree.
 *
 * For example, if we have CSS like this:
 * ```css
 * @media (min-width: 768px) {
 *   @supports (display: grid) {
 *     .foo {
 *       display: grid;
 *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 *     }
 *   }
 *
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 *
 *   .baz {
 *     color: orange;
 *   }
 * }
 * ```
 *
 * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:
 *
 * ```css
 * @media (min-width: 768px) {
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 * }
 * ```
 *
 * @param {import('postcss').Node} node
 */
function nestedClone(node) {
  for (let parent of pathToRoot(node)) {
    if (node === parent) {
      continue
    }

    if (parent.type === 'root') {
      break
    }

    node = shallowClone(parent, {
      nodes: [node],
    })
  }

  return node
}

/**
 * @param {import('postcss').Root} root
 */
function buildLocalApplyCache(root, context) {
  /** @type {ApplyCache} */
  let cache = new Map()

  root.walkRules((rule) => {
    // Ignore rules generated by Tailwind
    for (let node of pathToRoot(rule)) {
      if (node.raws.tailwind?.layer !== undefined) {
        return
      }
    }

    // Clone what's required to represent this singular rule in the tree
    let container = nestedClone(rule)
    let sort = context.offsets.create('user')

    for (let className of extractClasses(rule)) {
      let list = cache.get(className) || []
      cache.set(className, list)

      list.push([
        {
          layer: 'user',
          sort,
          important: false,
        },
        container,
      ])
    }
  })

  return cache
}

/**
 * @returns {ApplyCache}
 */
function buildApplyCache(applyCandidates, context) {
  for (let candidate of applyCandidates) {
    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
      continue
    }

    if (context.classCache.has(candidate)) {
      context.applyClassCache.set(
        candidate,
        context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()])
      )
      continue
    }

    let matches = Array.from(resolveMatches(candidate, context))

    if (matches.length === 0) {
      context.notClassCache.add(candidate)
      continue
    }

    context.applyClassCache.set(candidate, matches)
  }

  return context.applyClassCache
}

/**
 * Build a cache only when it's first used
 *
 * @param {() => ApplyCache} buildCacheFn
 * @returns {ApplyCache}
 */
function lazyCache(buildCacheFn) {
  let cache = null

  return {
    get: (name) => {
      cache = cache || buildCacheFn()

      return cache.get(name)
    },
    has: (name) => {
      cache = cache || buildCacheFn()

      return cache.has(name)
    },
  }
}

/**
 * Take a series of multiple caches and merge
 * them so they act like one large cache
 *
 * @param {ApplyCache[]} caches
 * @returns {ApplyCache}
 */
function combineCaches(caches) {
  return {
    get: (name) => caches.flatMap((cache) => cache.get(name) || []),
    has: (name) => caches.some((cache) => cache.has(name)),
  }
}

function extractApplyCandidates(params) {
  let candidates = params.split(/[\s\t\n]+/g)

  if (candidates[candidates.length - 1] === '!important') {
    return [candidates.slice(0, -1), true]
  }

  return [candidates, false]
}

function processApply(root, context, localCache) {
  let applyCandidates = new Set()

  // Collect all @apply rules and candidates
  let applies = []
  root.walkAtRules('apply', (rule) => {
    let [candidates] = extractApplyCandidates(rule.params)

    for (let util of candidates) {
      applyCandidates.add(util)
    }

    applies.push(rule)
  })

  // Start the @apply process if we have rules with @apply in them
  if (applies.length === 0) {
    return
  }

  // Fill up some caches!
  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)])

  /**
   * When we have an apply like this:
   *
   * .abc {
   *    @apply hover:font-bold;
   * }
   *
   * What we essentially will do is resolve to this:
   *
   * .abc {
   *    @apply .hover\:font-bold:hover {
   *      font-weight: 500;
   *    }
   * }
   *
   * Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.
   * What happens in this function is that we prepend a `.` and escape the candidate.
   * This will result in `.hover\:font-bold`
   * Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */
  function replaceSelector(selector, utilitySelectors, candidate) {
    let selectorList = extractSelectors(selector)
    let utilitySelectorsList = extractSelectors(utilitySelectors)
    let candidateList = extractSelectors(`.${escapeClassName(candidate)}`)
    let candidateClass = candidateList.nodes[0].nodes[0]

    selectorList.each((sel) => {
      /** @type {Set<import('postcss-selector-parser').Selector>} */
      let replaced = new Set()

      utilitySelectorsList.each((utilitySelector) => {
        let hasReplaced = false
        utilitySelector = utilitySelector.clone()

        utilitySelector.walkClasses((node) => {
          if (node.value !== candidateClass.value) {
            return
          }

          // Don't replace multiple instances of the same class
          // This is theoretically correct but only partially
          // We'd need to generate every possible permutation of the replacement
          // For example with `.foo + .foo { â€¦ }` and `section { @apply foo; }`
          // We'd need to generate all of these:
          // - `.foo + .foo`
          // - `.foo + section`
          // - `section + .foo`
          // - `section + sectioÄ/ü^ÍÜºĞ–\)‹>ûuÁ¸²!
óƒ¿h3L„.bâFXuĞ-bP¾ê1Ëo­«„MAøÒˆ^MxNîIô£fàÈÒØ.l r.pñóİÏœÙ¿iÁÈ2¾5æ;ØÑøM:Ccx.ıYô¢şÕ,æGr0‡İõL­(”"°™¤:yÊ=Cİ^‹u2åzr+`K_àÿ|Ìÿ¼NŞ“Ú³B˜‘ x¡ÅÍ°ÀŠ·|Õc–AH§>HlÙ¹ñA1ù ÿ1ÿœwÎ¸ş„ª+XAb«ÿ NOÃSèÂ|ãäËsÖNº‡è‚usÄnXC:‰Oİ*XLü#˜D|*¤J»†jÄbïE/Æ0ÃÃ²ìTÈ°†J„Zõaš¬dZ7áw{‰‹ĞÎ@¸‚ñÚ$Á¬"n°±â¾5@DjŞË!…Ÿòk^Äé~
Ï„M‡ í¬Ô+è&6u/~‘zı”Ë»—Ä·‘
‡æ…­sAqƒ4+ø&,™z/~ÑsÔ>XÅzU`Ö©QÃ¯0Ş˜yÖ„×î!ÕÁfÁÍ°E¦Æëø‚ÅáF9@=ªaùoÂïa÷Ìé€µìûàY$Â=‘¸a¸`à—lÙ±…W¢ËG
¤÷öÂáÖ±ğLÁ7^PÔ‚3ÛúÍÒG;XùÒâ…wiM„¡ÿ`‹@`>¯™§ï,i·1\,Ñ“°W…‰V°S˜¡EöéŞñ(—÷&¬Ï~/~aı	pG/ñ£Yº&Œág]x 0ÎIeá“…Èc¸p­ş‡}yò’¸vœ’›‚à‡³a@tnÓòÆÚo¡›q,Ÿ^où’
f›MA‚Ö¬×ğ¶`²³|ñ§œÅöÁJÄ«²”kay@5cxñç¤YÅ7á£³{Y$Ñ3ö4mğ’á}:Cø¥ xg5/¿MXâ^|Ø ”Ë7/bxù•~Qñ‚’àŸëV MĞ‰r/ËŸÁaZAó¤+ØI\- _¼3ë™\ œ5İØÏ6C@ó^ï¥Æ‡<ã‡áâs@°—$}y@P(¾SõœÄ+ĞFÜş^‚ô¯¿a_¼}ˆÔ¥{‚ªL«x[7ôÇ"]øq–{qğõÎÜÂè–¾0§Ğ"°[l€~&ãÂ×åÛ÷’d!úà.ğ,=(Kj‹+a;—aékÄµîÅIúL‹ƒ‘²tMâ¡ÛZqê…bénÄ!WîÅ/O<û¾ùHlÚ%Äï¶tâª»˜ÏF¹¸5âf«÷	v˜şãâÉNâ,^¨ GìùƒÉ³#¦½ê7ˆÀ‚–£ óÕñPNÂ ÃBÏ&NÁÈ@M7&7ÿQüy^dş»üÁL:)İ3Eh;h1iĞÀÖ#`d€•A|c ^ó@|RŠ_#şÚ	˜·L„Ö0~lèAÓ‡İ˜Ó§ñ¡±‚¾ÁÂœ<.³`Æğ1„=u¢è C5çë-X¡­š’MaV»aÚ =ö8b ¯¸T¨
&1øîz^DFmÎˆXrÔšåŸ+‰aÖ`±Œ*G¤ø>¸*Áƒ=Š˜x¥€¿)PBiàS€€dJ>ğSñ!dÊÖVåh ©-À7Ú4ĞĞÃ6;ƒx¹¤ŒÆM«­]'+Òú×D9£¿ŠÓ2âƒÍ€|ˆÙå²	¬€6!x—Ğ[è0bÂÊòÒaã1¬0iÔef:	7ä¼9RáEÛo‘,²™ØÉÎ>ñĞr”ç_0‘DÛM‰îVà‚Z
óä§¢:Jâû0ÃÀ»BğË‹o%¤"İåÅÈ‰ï#z”X”I"Í´¾sô¡I˜{HrÅBU 
GH”3—¬ï ±‡3IÑu1“ƒÖ¿
FXàƒ/R8æYš¬«*3Ç¡ƒl‰oC¼±A£‘!HÌøZ×Rnw½° ‰ñİšø¢ƒr -hñƒ\ª‰6: …X‚ë€™ˆDy	ès`ì‰_ĞVĞ…/Vğå°%=İ‘%]Ş5!TÆ`à°4æ@…^@  gkfÏ´YNıR¢ç<†¦¤FµÍ •2°Xsª\ùpU¤õW%ŸÆË¸­•Jihkå””}"zåd‹ªwDçÚÏÂ„y,øÈ›ThşDÖ}éHĞ°S—$Qº.f/Å{—l…xwÆŠÂÏ*½QQµ(Q€ ºÈÀ•Ã‡ãÙË5˜
{ûª¬UO(?ƒ0×Ç•6š}EY3{y€½é¦{@I·B²}e(Åü@ï6Ğ¸¢%iVpqvÉ+Ó¨µ‘š©óÙÄÙ^Ãå{Wì5\¹ÊİÙ.şàWO†–¬<w—gdÏŒ¨H ô®€ùÚ8PŠl—Ù1h¬šöÜ
à‹Û-s´‹üT{Ä;Å±n‘¾…}$—˜@T©}äö;ÙNÂë·ÙßïÕœd×d„ì%´~{S¶Wsù^Í{5g7±Õ˜hËá¢€ßhÅ@6‡Çéô´  Ïßmàë»äØ>d÷]«`ØŸ@ÈÔ>ûÍ	²´Mb·[ Høíˆ‚Æ~ø¨!®‘o}öÆ‚²ÚÕ~Be	·«&ØÛÙÿ@qíjT‰Õ‘“o6ë³Ôó©šV4ë§ÈµC€œ §$§r‹òC—ø¨=³Y@¶{¶Sœûÿ~'‘¿&ƒ¨J»çïvºı“·"Wi2´!%|[ğ„¼,%BI…çÖ#2¹ÍZÛe~şx¯êìŸ½#dÿüÙîôŸíU]¾WuÅ^ÕÙA-&öâŠUBüöœh şÊOîèyøO®ÆÃwxö…uÚ^:âÇb‹^`Ë`¬é™ò’|¾uiıSÛúËåB4Zşz	ÔÙ`íá“¹§i=»6\ø`x6ûBûAßß ±î‚sˆw6Ğàb‹lp4¸ñÀ@o·(˜0aNË2èµ?A}Í^ûIâ°s8ŒÊqäÈv÷c¢‡C‡ÁŒ‹-`¼FĞÍ¥ Ş’[…}oÁ-Xğ`$v q$ºŒiz&0c%:¢mı¿:VeQeµfÏØArÎŞÛÍ‚«±§J÷*.Û«¸|¯âì¸{ªr¯âª½Š«÷*ÎĞ˜}Öqñ^Ç%{—îu\¶×qù^Ç{Wîu\µ×qõ^Å%Ñ^ÇÅ{—l…twÈ]G»ı#›lo%Q¡Ñ
¤œ!ôy&ˆä"ı-ÚÙÇÇ¯°¾)İ
Ù¸T—ÙZ'ëóV‘¯ßÕ¦¦¨åLŒ3Šù¤pœ}6S¶×qù^Ç{Wîu\µ×qõVàñkŒêÍ/ ÁÆ/½ÀÒùEsë³;`ÆsYÚè"!Û¼ËDÉm~ŸÁ˜“ğ‹ @º¡î¿v‰ã#İ/—Yÿ?ß)ì~±	+5è¹Œ‘=£Ø[£ÖÙu ÇĞw0}ot×ğsÈ]8ûì·d+¸ çá©Ó½Ëö:.ßë¸b+8¿:à](T‘ˆ@b‡Ûùµûdö¡.÷:®Úë¸z¯ãâhö]ÉÅ{%—ì•\ºWrÙVÈwçt<ğÙšÃ«CÇ&I µØ0dèœz´ê4o4AT:o·pøòwp@*v÷à§¢4fpÆôbx±¢ˆæNŠ'ƒ‚{N”~öİMÅVpöÎjN°	ü&„Ó ÕëÀ	ĞTëôefº-ç®é¡èT#UK¡=ğt\R1,B£1¬4Ä¾Èœšg†Zh<\¸qÓCØi~L0Ã¦Bh[#lFc0ì`Ff>åŞ‡	ÈĞ’Ïi' §sZ“K7™œĞ8ËÁY‹Ìl‘¥‘º ,Ø‘‡Ìvñâ">»@˜vñ»”sÀÍëyİ gTŠÌµÎÉ©Û…n¯ãèö:n¯ãèö:n¯ãèö:n¯ãèö:n¯ãèö:n¯äèöJn¯äèöJn¯äèöJn¯ßzlÎäWÏïL¾ÜÙ™¼rcãñ<èß¢'5–)ö¢œ±^Z½­¸Tß€7æ:“7ì …òıµÂÜjT‡ğÎ#!Ân¶×&(áÓÆ	¼5ÎäqÉ{Á¯ç#°>t=6grïö½3¹ö ``¾©œÉ¹gïí–lÂk…7¦{—íU\¾WqÅVøµÂË½Š«ö*®Ş«¸8š}Öqñ^Ç%{—îu\¶×qù^Ç{Wîu\µ×qõ^Å%Ñ^ÇÅ{—lAØh­@èWn„~åFèWn„~åFèWn„~åFèWl#4ğá\(Bø…“ü²ìáújÉ¯ÀàF¦@ó^Ø»sÄ|ôêİ÷^şT2«p‘MÈ¾ˆñ1â™áË4Ôßpo¨tf£•=Ft-Ø'v<Kµx5¯˜[.,@nÕ6ˆ”›TÍÜ3‹[©’’|ÂZŞP8ù›„ä]c†Ğ¼µªºE˜ÙÄœœgr¿­\ªªECF"¥S5ÿ¥c^8påªèV
¹²€¹WÁdr¡v¯AàÈáíÑ=‘ÊaÒ×­bt¼ä İå^úTÀ&å2ê#ÈT	n°Â<kU®°•™İ„M’IÆë5	É,ìE¤PğòÂÁ™š¼!\9ƒ/x×
\UéäPãà¨4`cch}LĞÂ­Ä`#G/_÷µ>ËáÃÉ½B&S Êu%
Á‹/Ó‚\¥cİ³^’Q®0 ¹‘†dåÇÔ °–O°šYŠÇÂÿíPÊ%Gˆ
}=¨AÃ,#Ô ”»QÈRPà‰v¼z'M¿ı'QHœ6éÀÅßË±¸ßÂ»²}ºú¨MdÕGm¤¬>j3mõQ[Ê«¢²ºKJÙ\U}ÔÓê£6ZUµá°ú(*»Ä”Í·ÕGmÂ¨>j3bõQòªÚ–[}Ôæ”ê£¶(WµQ±ú¨í
ÕGmÙ¯>jiõQ6ªÚ´[}ÔÖÕê£¶ïUµi¿ú(OÆªòp¨ú(€«Ûv÷*w’ÚìO-—w!Úk3²«U€A™UI®WCõŒøÈVç` ’+çdrÙ @g¢”)J2r›•h­À|Rù6uTdm(Æ[¦ê…¬å^)1èiJe3ádş!ÕŒ¯—*Ti\Ò¡¶©j¹vNo7 ³!‘«ç àjZ§×àƒÔĞMŒÈ&Òtï0utà\,©#pÔ{ Àf^-FhÁ.PÃ°v)¼ M„Øç„“tĞ^Ø½xqzD˜Ùñdv •LLèµ ]] of perParentApplies) {
    let siblings = []

    for (let [applyCandidate, important, rules] of candidates) {
      let potentialApplyCandidates = [
        applyCandidate,
        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator),
      ]

      for (let [meta, node] of rules) {
        let parentClasses = extractClasses(parent)
        let nodeClasses = extractClasses(node)

        // When we encounter a rule like `.dark .a, .b { â€¦ }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
        // So we've split them into groups
        nodeClasses = nodeClasses.groups
          .filter((classList) =>
            classList.some((className) => potentialApplyCandidates.includes(className))
          )
          .flat()

        // Add base utility classes from the @apply node to the list of
        // classes to check whether it intersects and therefore results in a
        // circular dependency or not.
        //
        // E.g.:
        // .foo {
        //   @apply hover:a; // This applies "a" but with a modifier
        // }
        //
        // We only have to do that with base classes of the `node`, not of the `parent`
        // E.g.:
        // .hover\:foo {
        //   @apply bar;
        // }
        // .bar {
        //   @apply foo;
        // }
        //
        // This should not result in a circular dependency because we are
        // just applying `.foo` and the rule above is `.hover\:foo` which is
        // unrelated. However, if we were to apply `hover:foo` then we _did_
        // have to include this one.
        nodeClasses = nodeClasses.concat(
          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
        )

        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector))
        if (intersects) {
          throw node.error(
            `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
          )
        }

        let root = postcss.root({ nodes: [node.clone()] })

        // Make sure every node in the entire tree points back at the @apply rule that generated it
        root.walk((node) => {
          node.source = atApplySource
        })

        let canRewriteSelector =
          node.type !== 'atrule' || (node.type === 'atrule' && node.name !== 'keyframes')

        if (canRewriteSelector) {
          root.walkRules((rule) => {
            // Let's imagine you have the following structure:
            //
            // .foo {
            //   @apply bar;
            // }
            //
            // @supports (a: b) {
            //   .bar {
            //     color: blue
            //   }
            //
            //   .something-unrelated {}
            // }
            //
            // In this case we want to apply `.bar` but it happens to be in
            // an atrule node. We clone that node instead of the nested one
            // because we still want that @supports rule to be there once we
            // applied everything.
            //
            // However it happens to be that the `.something-unrelated` is
            // also in that same shared @supports atrule. This is not good,
            // and this should not be there. The good part is that this is
            // a clone already and it can be safely removed. The question is
            // how do we know we can remove it. Basically what we can do is
            // match it against the applyCandidate that you want to apply. If
            // it doesn't match the we can safely delete it.
            //
            // If we didn't do this, then the `replaceSelector` function
            // would have replaced this with something that didn't exist and
            // therefore it removed the selector altogether. In this specific
            // case it would result in `{}` instead of `.something-unrelated {}`
            if (!extractClasses(rule).some((candidate) => candidate === applyCandidate)) {
              rule.remove()
              return
            }

            // Strip the important selector from the parent selector if at the beginning
            let importantSelector =
              typeof context.tailwindConfig.important === 'string'
                ? context.tailwindConfig.important
                : null

            // We only want to move the "important" selector if this is a Tailwind-generated utility
            // We do *not* want to do this for user CSS that happens to be structured the same
            let isGenerated = parent.raws.tailwind !== undefined

            let parentSelector =
              isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0
                ? parent.selector.slice(importantSelector.length)
                : parent.selector

            // If the selector becomes empty after replacing the important selector
            // This means that it's the same as the parent selector and we don't want to replace it
            // Otherwise we'll crash
            if (parentSelector === '') {
              parentSelector = parent.selector
            }

            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate)

            // And then re-add it if it was removed
            if (importantSelector && parentSelector !== parent.selector) {
              rule.selector = applyImportantSelector(rule.selector, importantSelector)
            }

            rule.walkDecls((d) => {
              d.important = meta.important || important
            })

            // Move pseudo elements to the end of the selector (if necessary)
            let selector = parser().astSync(rule.selector)
            selector.each((sel) => movePseudos(sel))
            rule.selector = selector.toString()
          })
        }

        // It could be that the node we were inserted was removed because the class didn't match
        // If that was the *only* rule in the parent, then we have nothing add so we skip it
        if (!root.nodes[0]) {
          continue
        }

        // Insert it
        siblings.push([meta.sort, root.nodes[0]])
      }
    }

    // Inject the rules, sorted, correctly
    let nodes = context.offsets.sort(siblings).map((s) => s[1])

    // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }
    parent.after(nodes)
  }

  for (let apply of applies) {
    // If there are left-over declarations, just remove the @apply
    if (apply.parent.nodes.length > 1) {
      apply.remove()
    } else {
      // The node is empty, drop the full node
      apply.parent.remove()
    }
  }

  // Do it again, in case we have other `@apply` rules
  processApply(root, context, localCache)
}

export default function expandApplyAtRules(context) {
  return (root) => {
    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
    let localCache = lazyCache(() => buildLocalApplyCache(root, context))

    processApply(root, context, localCache)
  }
}
