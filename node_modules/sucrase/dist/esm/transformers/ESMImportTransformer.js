


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to a                           !   Spec ID Event03                         Ôr@	C‚¸V€ù	?kêŠ´}(=³+n«í»ñU   ûkTU@¤­Nô¿¸:           åGÒ*&@ô›ëÊ¶5<Ì¹W…?y%ZÃèµ’˜mÑ     ®ÿ                €    Z¨'ÛÌûDÒ­ÏÚV½êb†
”¾Õ·¢{ºMØ5   aßä‹Ê“Òª à˜+Œ
              S e c u r e B o o t       €    Ş§¸
µ:=ª¢M\ÄldáúŸısŸªÛØÀ†|J[H$   aßä‹Ê“Òª à˜+Œ               P K      €    æpá!üëÔs¸¼A»€üšú3O÷›tñ,G¦&   aßä‹Ê“Òª à˜+Œ               K E K      €    ºøš<ÊÎRu_(5"¤—¡­ıP‚*£c¹Ñ$ê|$   Ë²×:=–E£¼ÚĞgeo               d b      €    ùïí]¸DÿÆÌ“¡‚_œ¬á€ ™u1i‰ƒÂ9·ò(  Ë²×:=–E£¼ÚĞgeo       Ì(      d b x &ÄÁLP’@¬©Aù6“C(Ì(      0   ½šúwY2M½`(ôçxK€´Ùi1¿ı‘¦ÑO¤Ræm²@Œ¨`MA’eŸ
½šúwY2M½`(ôçxKõ/ƒ£úœûÖ’r($ÛäE4Ò[…$k;•}¬nÎz½šúwY2M½`(ôçxKÅÙØ¡†âÈ-	¯ª*o.s‡>d÷,Nïgyj„½½šúwY2M½`(ôçxKì„¸Kle¥ ©¾q–R0!bÖÓ<H™œk)Z+
½šúwY2M½`(ôçxKÃ©šF¤d WÃXmƒÎõô®·9yí‰2t-ğíSf½šúwY2M½`(ôçxKXû”ï•¢YC³û_% ß?äLXÉ^
¸‡)uh«—q½šúwY2M½`(ôçxKS‘Ã¢û!¦ªÜ%®wáŸ]o	Í	î²P™"¿ÍY’ê½šúwY2M½`(ôçxKÖ&~jq‹Á$«¢|»e, :{k%}½Ë½`ö^óÑ½šúwY2M½`(ôçxKĞcì(ö~ºSñd-¿}ÿ3Æ£*İ†Ÿ`ş.,2ñËåm½šúwY2M½`(ôçxK)ÆëR´<:¡‹,Øín¨`|ï<úáºşeu\òæ„JD½šúwY2M½`(ôçxKûçiÖ3@>h2Û²Ò	à'%'ß¶=IÒ•r¦ôL½šúwY2M½`(ôçxKo¬êÏìıN0;tô€ €˜âĞ€+“oÇtÎ!ó†hœ½šúwY2M½`(ôçxKN:[CÆ¦»Ó@O4=Ï9bgÎ”øµ.#©Ú’½šúwY2M½`(ôçxK+™Ï&B.’ş6_¿KÃ'láKzoÿDû/ki™9½šúwY2M½`(ôçxK.p‘g†¦÷sQ§«pµWÆ2.©#²¨Ó¹+Q¯}½šúwY2M½`(ôçxK?Î›Ÿß>ğTR°ù^äÂ·ğmt:syqUpjÎ>s½šúwY2M½`(ôçxKGÌa'âš†à:kï,ÔøÅZmkÛ6!hÃ,ã*Zß½šúwY2M½`(ôçxKqòoÒ"I~T£Fb«$—üÈ wõhéãÙ¿Ëıcu½šúwY2M½`(ôçxK‚Û;Î´öCÎ—ÃÑ‡Í›YAÍ=èXo+ÚV7W_g½šúwY2M½`(ôçxKŠÖHYñ•µõ¯ª”jag¬ÖzˆnF“dr!ÅYE¹½šúwY2M½`(ôçxK¢‰Ïç
«seË(îQíÓ<òPmèˆû­Ö¿€H½šúwY2M½`(ôçxK®ë®1Q'sí•ª.g9í1©…g0:3"˜ø7	©ÕZ¡½šúwY2M½`(ôçxKÄ	½¬Gu­ØÛ’ª"µ·ûŒ”¡F,é¤¹]Š3ˆÂü½šúwY2M½`(ôçxKÆÁ¨±î*(µ¨Lƒ×É‹['(aëæ’Â–½šúwY2M½`(ôçxKÉ3f¸çùƒ—TÉ—ñsë&Ø¡¹ã½¿Æg«Û‹½šúwY2M½`(ôçxKdW[Ùxš.­Vö4R¯køùD xYuéğN-d×E½šúwY2M½`(ôçxKEÇÈ®u
Ï»Hü7R}dİdM®Ø‘<ÍŠ$ÉM…igß½šúwY2M½`(ôçxKØûL.z‚%ekK‚s·Ë¤°>òéë à )$ì¡º†½šúwY2M½`(ôçxK¹*ò˜Ü›xÇt’ÖUq×*­£×{åF	ä2xïnM½šúwY2M½`(ôçxKá®ƒÀ.o(XÔëÑw#´õê5yÕD=ìÅù<½šúwY2M½`(ôçxK9ÛÂ(ôK_•3,·wãè@Û¦€cJ¨õÉ± ½šúwY2M½`(ôçxK2õ”¢Ø¢ÁEæü‰df(ÿÌ|zBÊå3})Ä½½šúwY2M½`(ôçxKÔ_Ë£–®ó>èöì®X¯èGj(
 &üqö!}ÏIº/½šúwY2M½`(ôçxKK†h¥Ôe¼İ ªüÿBOËĞ®Î2üp¨>‘`èŸ	½šúwY2M½`(ôçxK‰óÑöä…Ã4Í	•ãÍıÀq±„˜T„zDÜUHâÜû½šúwY2M½`(ôçxKÉì5ònUšÿ´âëŞT5L5©˜`[Ï—-U½šúwY2M½`(ôçxK³å4¿kW†—3“Ÿ$¶k¤eã^‘°6**ÍépI½šúwY2M½`(ôçxKŸcíWÃ”´.ñ
f±D¦[¡¶WùK²ğÄÍ`Á½šúwY2M½`(ôçxKİY¯VDãŒcûà…0 ÍwF*!’Y°[ÂYæs½šúwY2M½`(ôçxKÛ¯m=[8¶…S0J¼ˆ‚~¼ ø¹Çá—Í¼X"Í1l½šúwY2M½`(ôçxKeóÀ „Ób¹r.˜÷^^™ln“O{+.kæŞÈ ì½šúwY2M½`(ôçxK[$‘=q…==¥®İšKÅz‘q&W8û_Ë-†¢ñÈ†½šúwY2M½`(ôçxK&yeãAòÏ¨ƒF5Vª¯w§kÄ„É0tl÷µ½šúwY2M½`(ôçxK»ÑmS co##§¨o=ÿ–Ÿ„ˆÀWKÂ×‡şÉ?½šúwY2M½`(ôçxKà! ö|~ø_Ní6¿p’8
<#Ê‘ıC”°½šúwY2M½`(ôçxK•ŸA7Ç°Òvq•åos€}:Üøöç¿-M™0_‰½šúwY2M½`(ôçxKæ!jÊïd@¥Uì¾Ù@±¥òVší’•a7®XH.ñ·½šúwY2M½`(ôçxKnşş[G‹{”LÓ¨¬¢Ì¤ ˆˆâŸŠËX$×º°½šúwY2M½`(ôçxK ®LÔzAÇƒÜHóBÀvÂÁo4ôÒßPÑÊ;µ­…½šúwY2M½`(ôçxKØÔæİöä-t¦¥6êbıä)\\6•£Bïµõ¤½šúwY2M½`(ôçxKòw¯O›Ü‘ŠèŸ£\Á³N4˜L®—e2,<°IWM6Pœ½šúwY2M½`(ôçxKÂLuëïV¹ñ:¹Ş`âì¡ÄQ 4â»³lö
T›#L½šúwY2M½`(ôçxKƒXò¥W-pYµÈcPU(’éEbo_ÉÊ¬÷½èW¤½šúwY2M½`(ôçxKºßõäğş§p¨û"äÄ8!ã!õ-OtİPñĞ9¼½šúwY2M½`(ôçxKÄR«„`sßZÎ%Ì¦Mkz	Ù0ŠeëR@ãÄëÊ©Ì½šúwY2M½`(ôçxKñ†>È·ô?”­û‹JiIzŒeì¼*Uà»Bw+ŒÜ‘½šúwY2M½`(ôçxK{ÉËTcÎµ^¸ºwÑ¬ÒƒÄ?JW`<Áò,ëÅy½šúwY2M½`(ôçxKè 9]¾Wè Qx´ºõ¢Wğn‘!¦|Y_jâ%ı½šúwY2M½`(ôçxK´ÜÊòÈÏ§´“qş+–‘ä!oÙT(g-l~s½šúwY2M½`(ôçxK>Î'Ë³ìD8Ìå#¹'Äğ_Ü\Y:7fÛ˜L^Cz?ö¡k½šúwY2M½`(ôçxKhîF2Ç¾fÈ>‰İ“êî”š¿E´ÂÇ-}ÇIš¢ C½šúwY2M½`(ôçxKâK1ZUqH=‹s³-áMáë.«!ı-œ1Ÿõ^Ğ½šúwY2M½`(ôçxKçÂ:´ìˆUì¥)7ØKZÂOˆ&kRpçì´ª%8½šúwY2M½`(ôçxKÜÌ<áÀä°±‡Ór úGõÂoW£Y¾{'€N¬ºÄ½šúwY2M½`(ôçxKWÿq*ä‰³t“Àv§Í©a)Ø¨ıhÒ¶¯c91]½šúwY2M½`(ôçxK:‘ğùå(¢™L}“,^áLèáÈ0Jä•­ÅŒÄE<½šúwY2M½`(ôçxKIS yl›òQ«¥³Õ~+…××d4ìuº£…tå½šúwY2M½`(ôçxK¨²Éuë«§ÛŞ^éiÀêî*1Ã‹‘¨gV¦·p½šúwY2M½`(ôçxKSïÜøRÎå¦é)1¼Bæ<ÓöIÌ§èrRÃ¤Y–½šúwY2M½`(ôçxK™-5š§¥÷‰Òh¹L¹HZkæCb°í´DÌ|9d{½šúwY2M½`(ôçxKŸ¤Õ?Ô>ÊÿB º~CS%+~^rµ	nÿ€'ÖmC½šúwY2M½`(ôçxKÓrÀĞôıÉõ.#üVîrAJóPĞÎ¦Âj5¦Ã!z½šúwY2M½`(ôçxK\Xj…é7‰EpÔùëh(¹|AË›¦ÓÜÌ_RzU½šúwY2M½`(ôçxKöJ)”Šˆ¾ÿÛ^	§7ÏÙÎkÏd!1«‡½šúwY2M½`(ôçxKØ~q4Tao[×„šµÁq*¸O4”xì*8ùpÀ‰½šúwY2M½`(ôçxKë[­ÒnO®eù¤#XŞï|å,À_»Çgvæ˜*½šúwY2M½`(ôçxK»"‰ééM ÿ?bQj°~—›,lïâ«pÆßÁŸ¥½šúwY2M½`(ôçxK	(ğ@‹÷%ægØq8¨î¼R–-(Gñn5‡;A¶­½šúwY2M½`(ôçxK	ùŠ©…Œsø›§~‡ìoYlIPû‹º€¦/»‘K½šúwY2M½`(ôçxK
uêpê¤Óót$mµOÇ´>Yj53	¹ÃkOÙur^½šúwY2M½`(ôçxKQ×oÄ“Iv]¨†‚Bk,şj¤òrSê´ 2ã§½šúwY2M½`(ôçxK£¢šĞQ0×ş[ôÒYecÍí‡@–ªÌi“*.IQš½šúwY2M½`(ôçxKw0´/şI?é¶%—Í+o4Ójõ“0ñ¤/”½šúwY2M½`(ôçxKáqZŸÏá¤DÎÿ…†´"3ÀK1L)]m§½šúwY2M½`(ôçxK‘¨Ôså(¨x#½bæUß®Tú+úrıÀ)†Ö¸½šúwY2M½`(ôçxK‹XÁı¸Ú‹3Ìî_—:÷4Ùóã?]±W<+ ˆ¨½šúwY2M½`(ôçxK‘†ïß^òŞ‚Eº®4††º5ÿ=˜eÁS|í“½šúwY2M½`(ôçxK'„²†ñc°jªäë¸ßøŞ}‚[ˆ9ÿf'NÿG½šúwY2M½`(ôçxK)Ì¤TN£0Ö‘Ç„i\œk "¬{[‰Ë×( Ñ@ê½šúwY2M½`(ôçxK+"˜ê¢kÄ¤UŠé.{°äø\óKøHıö6ÀÁ¾Ä˜—½šúwY2M½`(ôçxK-Ïp#ÑèáE=hÖì0Ù¾ÙL¼¸İÁÌ¬½šúwY2M½`(ôçxK1*Å[PÀ›0³Ì“¹”¡>î¬Tï‰/ÄG»½–¡½šúwY2M½`(ôçxK2­2–‚›ÄmÏ¬^İË¿,í\ø;"Ïœn`Ç˜Ô§½šúwY2M½`(ôçxK4£+X3+V¯0©ßÖ¹Ò'àâ£IX±Æ%…½šúwY2M½`(ôçxK6.Ó ±à’(1©o

ÏŞa‰Sæ•Éï.°ºÃuP½šúwY2M½`(ôçxK6z1åƒˆ1­,FGˆjlßòæ±º‘ÿ…Üz‡®›^˜½šúwY2M½`(ôçxK7e×iÀ[ù‹B{5;!7è¤›o…
ñYíj†xj¦4½šúwY2M½`(ôçxK8mi\ß-EvàÊÌõäxÚQ¯™UÀ¸úv7; y”³½šúwY2M½`(ôçxK:Ot¾¯®+“ƒ­‚Ò3¦Ï=³Çâè—¾ïBUúî½šúwY2M½`(ôçxK:çlEÊpéY˜Bb-ÒQ¼¡ûæ¹Å.Ás°5½šúwY2M½`(ôçxK;èçë45Á’Çi„gˆ™AÑöÏ	QL¡i“OsY½šúwY2M½`(ôçxK>9&ğ¸¡ZÕ¡Ag»dz„<=C!ã]¼DÜèÈ7A-(°½šúwY2M½`(ôçxK@
ÆmY·°”©ã¦½:ÿ0WƒçY/B¾_ôº½šúwY2M½`(ôçxKA…‚m«[¨4{x¢+_š
upÊ\“§MGŠy=ƒºÄ˜½šúwY2M½`(ôçxKAÑî±wÀ2NİeWó„å2ŞõšDkï³Q¼%w½šúwY2M½`(ôçxKE‡kMØaÔ[:”€tz]´ZH²§)A	¶A/Š‡é]½šúwY2M½`(ôçxKFg¿%×Á k„tÆÍ±ßdŠXso¿WĞ]ou]«gô½šúwY2M½`(ôçxKGÿc±@¶üíy1æQÚ[./]®ô=ÂûÅ2±½šúwY2M½`(ôçxKWæ‘:úÌR"½vÍ¯1øíˆ‰Td%Stï	z‚×õšÓ•–½šúwY2M½`(ôçxKXú"q!ÇmícÈ~:e3î öğ¡¢?ÄE›Æ¼ß½šúwY2M½`(ôçxK]šË»J}KhRßYpâÎÖoö"îœĞíØAÌ­½šúwY2M½`(ôçxKaÎÄ£w¿YÀş®ãp4¿—Õ¼nâ:ßºæãõû<ı½šúwY2M½`(ôçxKcW´E6,Æ˜KÄ¶(â=¾$¶élŠãÜ°Õ¬½šúwY2M½`(ôçxKe²çÌÙÃ1ßRßsÊÉ2ÒŸ™tÅo0‡²İ1G½šúwY2M½`(ôçxKfª íÂ8MœB]9'æíJ]@ÅçÍM¬ˆõwòñ½šúwY2M½`(ôçxKhsÒö)½RéTîÿYwªƒgC™—bÿ!,”3Æ—½šúwY2M½`(ôçxKm»êÒ>Œ†ø´tûü¥ Mãâ‹ˆ»ÌÜGG“N½šúwY2M½`(ôçxKmêÑ2WßÃÌÆ¤³pº‘u_éàìAP0”.Z¼Gğ|ˆ½šúwY2M½`(ôçxKp¡E
ò­9Ui­
ş±ÙÁ%