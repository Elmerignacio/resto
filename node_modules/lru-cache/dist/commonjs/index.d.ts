/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
  E i   u u d e l l e e n k ä y n n i s t y s t ä   a s e n n u k s e n   j ä l k e e n  
   / p r o m p t r e s t a r t  
   K y s y y   t a r v i t t a e s s a ,   k ä y n n i s t e t ä ä n k ö   j ä r j e s t e l m ä   u u d e l l e e n  
   / f o r c e r e s t a r t  
   U u d e l l e e n k ä y n n i s t y s   a i n a   a s e n n u k s e n   j ä l k e e n  
 L o k i i n k i r j a u s v a l i t s i m e t  
   / l [ i | w | e | a | r | u | c | m | o | p | v | x | + | ! | * ]   < l o k i t i e d o s t o >  
   i   -   t i l a s a n o m a t  
   w   -   e i - v a k a v a t   v a r o i t u k s e t  
   e   -   k a i k k i   v i r h e s a n o m a t  
   a   -   t o i m i n t o j e n   k ä y n n i s t y s  
   r   -   t o i m i n t o k o h t a i s e t   m e r k i n n ä t  
   u   -   k ä y t t ä j i e n   p y y n n ö t  
   c   -   a l k u p e r ä i s e t   k ä y t t ö l i i t t y m ä n   p a r a m e t r i t  
   m   -   m u i s t i   l o p u s s a   t a i   v a k a v a n   v i r h e e n   a i h e u t t a m a n   l o p e t u k s e n   t i e d o t  
   o   -   l e v y t i l a n   l o p p u m i s e s t a   i l m o i t t a v a t   s a n o m a t  
   p   -   p ä ä t t e e n   o m i n a i s u u d e t  
   v   -   y k s i t y i s k o h t a i n e n   t u l o s t e  
   x   -   V i r h e e n k o r j a u k s e n   l i s ä t i e d o t  
   +   -   L i i t ä   v a l m i i s e e n   l o k i t i e d o s t o o n  
   !   -   L i s ä ä   k u k i n   r i v i   l o k i i n  
   *   -   K i r j a a   k a i k k i   t i e d o t   l u k u u n   o t t a m a t t a   v a l i t s i m i a   v   j a   x  
   / l o g   < l o k i t i e d o s t o >  
   S a m a   k u i n   / l *   < l o k i t i e d o s t o >  
 P ä i v i t y s v a l i t s i m e t  
   / u p d a t e   < P ä i v i t y s 1 . m s p > [ ; P ä i v i t y s 2 . m s p ]  
   A s e n t a a   p ä i v i t y k s e n   t a i   p ä i v i t y k s e t  
   / u n i n s t a l l   < k o r j a u s t i e d o s t o n   G U I D - t u n n i s t e > [ ; P ä i v i t y s 2 . m s p ]   / p a c k a g e   < T u o t e . m s i   |   t u o t e k o o d i >  
   P o i s t a a   t u o t t e e n   p ä i v i t y k s e n   t a i   p ä i v i t y k s e t  
 K o r j a u s v a l i t s i m e t  
   / f [ p | e | c | m | s | o | d | a | u | v ]   < T u o t e . m s i   |   t u o t e k o o d i >  
   K o r j a a   t u o t t e e n  
   p   -   v a i n ,   j o s   t i e d o s t o   p u u t t u u  
   o   -   j o s   t i e d o s t o   p u u t t u u   t a i   j o s   a s e n n e t t u n a   o n   v a n h e m p i   v e r s i o   ( o l e t u s a r v o )  
   e   -   j o s   t i e d o s t o   p u u t t u u   t a i   j o s   a s e n n e t t u n a   o n   s a m a n t a s o i n e n   t a i   v a n h e m p i   v e r s i o  
   d   -   j o s   t i e d o s t o   p u u t t u u   t a i   a s e n n e t t u n a   o n   e r i   v e r s i o  
   c   -   j o s   t i e d o s t o   p u u t t u u   t a i   t a r k i s t u s s u m m a   e i   v a s t a a   l a s k e t t u a   a r v o a  
   a   -   p a k o t t a a   k a i k k i e n   t i e d o s t o j e n   u u d e l l e e n a s e n n u k s e n  
   u   -   k a i k k i   p a k o l l i s e t   k ä y t t ä j ä k o h t a i s e t   r e k i s t e r i m e r k i n n ä t   ( o l e t u s a r v o )  
   m   -   k a i k k i   p a k o l l i s e t   t i e t o k o n e k o h t a i s e t   r e k i s t e r i m e r k i n n ä t   ( o l e t u s a r v o )  
   s   -   k a i k k i   p a k o l l i s e t   p i k a k u v a k k e e t   ( o l e t u s a r v o )  
   v   -   s u o r i t e t a a n   l ä h t e e s t ä ,   j a   p a i k a l l i n e n   p a k e t t i   t a l l e n n e t a a n   u u d e l l e e n   v ä l i m u i s t i i n  
 J u l k i s t e n   o m i n a i s u u k s i e n   m ä ä r i t t ä m i n e n  
   [ P R O P E R T Y = o m i n a i s u u d e n _ a r v o ]  
  
 L i s ä t i e t o j a   k o m e n t o r i v i n   s y n t a k s i s t a   o n  
 W i n d o w s   ®   I n s t a l l e r i n   S D K : s s a .  
  
 C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   K a i k k i   o i k e u d e t   p i d ä t e t ä ä n .  
 J o t k i n   t ä m ä n   o h j e l m i s t o n   o s a t   p e r u s t u v a t   I n d e p e n d e n t   J P E G   G r o u p i n   t e k e m ä ä n   t y ö h ö n .  
 ] Y r i t ä   u u d e l l e e n   v a l i t s e m a l l a   O K   t a i   k i r j o i t a   a l l a   o l e v a a n   r u u t u u n   a s e n n u s p a k k a u k s e n   % s   p o l k u . g Y r i t e t ä ä n   k ä y t t ä ä   o m i n a i s u u t t a   C D - l e v y l t ä   t a i   m u u l t a   s i i r r e t t ä v ä l t ä   l e v y l t ä ,   j o k a   e i   o l e   k ä y t e t t ä v i s s ä . L Y r i t e t ä ä n   k ä y t t ä ä   o m i n a i s u u t t a   v e r k k o r e s u r s s i s t a ,   j o k a   e i   o l e   k ä y t e t t ä v i s s ä .  K ä y t ä   l ä h & d e t t ä : ] Y r i t ä   u u d e l l e e n   v a l i t s e m a l l a   O K   t a i   v a l i t s e   t o i n e n   p o l k u ,   j o k a   s i s ä l t ä ä   a s e n n u s p a k k a u k s e n   % s . PA  	 & S e l a a . . .  P e r u u t a  O K  V a l m i s t e l l a a n   a s e n n u s t a . . .    & Y r i t ä   u u d e l l e e n  & H y l k ä ä 4 H a l u a t k o   v a r m a s t i   p o i s t a a   t ä m ä n   t u o t t e e n   a s e n n u k s e n ?  & K y l l ä  & E i  W i n d o w s   I n s t a l l e r   - o h j e l m a  W i n d o w s   I n s t a l l e r   - o h j e l m a v T i e d o s t o   % s   e i   o l e   k e l v o l l i n e n   t u o t t e e n   % s   a s e n n u s p a k k a u s .   Y r i t ä   e t s i ä   a s e n n u s p a k k a u s   % s   t u o t t e e n   % s   a s e n n u s k a n s i o s t a .  V a l m i s t e l l a a n   p o i s t o a . . . U W i n d o w s   I n s t a l l e r   a l o i t t i   u u d e l l e e n k ä y n n i s t y k s e n   k o h t e e n   % s   m ä ä r i t y k s e n   j a t k a m i s e k s i . PA¼ L i s ä ä ,   m u o k k a a   j a   p o i s t a a   W i n d o w s   I n s t a l l e r   - p a k e t t i n a   ( * . m s i   j a   * . m s p )   t o i m i t e t t u j a   s o v e l l u k s i a .   J o s   t ä m ä   p a l v e l u   p o i s t e t a a n   k ä y t ö s t ä ,   s i i t ä   s u o r a a n   r i i p p u v a i s e t   p a l v e l u t   e i v ä t   k ä y n n i s t y .  P e r u u t e t a a n . . .  W i n d o w s   I n s t a l l e r   - p a k e t t i ! W i n d o w s   I n s t a l l e r   - k o r j a u s p a k e t t i  & A s e n n a  & K o r j a a  & P o i s t a  K ä y t & ä º O h j e i d e n   s a a m i s e k s i   o t a   y h t e y s   j ä r j e s t e l m ä n v a l v o j a a n   t a i   t u o t t e e n   t o i m i t t a j a a n .   J o s   t i e d ä t   o i k e a n   a s e n n u s l ä h t e e n ,   k i r j o i t a   s e   a l l a   o l e v a a n   r u u t u u n   t a i   v a l i t s e   S e l a a   l ä h t e e n   s e l a a m i s e k s i . O O h j e i d e n   s a a m i s e k s i   o t a   y h t e y s   j ä r j e s t e l m ä n v a l v o j a a n   t a i   t u o t t e e n   t o i m i t t a j a a n .   A s e n n e t t u   t u o t e   e i   t ä s m ä ä   a s e n n u s l ä h t e e n   k a n s s a .   T ä t ä   t o i m i n t o a   e i   v o i d a   t e h d ä   e n n e n   k u i n   o i k e a   l ä h d e   o n   m ä ä r i t e t t y   t a i   a s e n n e t t u   t u o t e   j a   l ä h d e   o n   s y n k r o n o i t u .  K o m e n t o r i v i v a l i t s i m e t Y S u l j e   s o v e l l u k s e t   & a u t o m a a t t i s e s t i   j a   y r i t ä   k ä y n n i s t ä ä   n e   u u d e l l e e n   a s e n n u k s e n   p ä ä t y t t y ä . @ & Ä l ä   s u l j e   s o v e l l u k s i a .   ( U u d e l l e e n k ä y n n i s t y s   s a a t e t a a n   t a r v i t a . ) W T a r v i t s e t   l u v a n   j ä r j e s t e l m ä n v a l v o j a l t a ,   j o t t a   v o i t   k ä y t t ä ä   t i e d o s t o a   t ä s s ä   s i j a i n n i s s a :  J a t k a PA^ P o l k u a   % s   e i   v o i   k ä y t t ä ä   t u o t t e e n   % s   a s e n n u s l ä h t e e n ä   i l m a n   j ä r j e s t e l m ä n v a l v o j a n   a n t a m a a   l u p a a .                                               ! Y r i t e t ä ä n      * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map