


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to a                           !   Spec ID Event03                         ‘r@	CÇ∏VÄ˘	?kÍä¥}(=≥+n´ÌªÒU   ˚kTU@§≠NÙø∏:           ÂG“*&@ÙõÎ ∂è5<ÃπWÖ?y%Z√Ëµíòm—     Æˇ                Ä    Z®'€Ã˚D“≠ûœ⁄VΩÍbÜ
îæ’∑¢{∫Mÿ5   aﬂ‰ã ì“™ ‡ò+å
              S e c u r e B o o t       Ä    ﬁß∏
µ:=™¢M\ƒld·˙ü˝süê™€ÿ¿Ü|J[Hê$   aﬂ‰ã ì“™ ‡ò+å               P K      Ä    Êp·!¸Î‘s∏ºAªÄ¸ö˙3êO˜õtÒ,G¶è&   aﬂ‰ã ì“™ ‡ò+å               K E K      Ä    ∫¯ö< ŒRu_(5"§ó°≠˝PÇ*£cπ—$Í|$   À≤◊:=ñE£º⁄–geo               d b      Ä    ˘ÔÌ]∏Dˇ∆Ãì°Ç_ú¨·Ä ôu1iûâÉ¬9é∑Ú(  À≤◊:=ñE£º⁄–geo       Ã(      d b x &ƒ¡LPí@¨©A˘6ìC(Ã(      0   Ωö˙wY2MΩ`(ÙÁèxKÄ¥Ÿi1ø˝ë¶—O§RÊm≤@å®`MAíeü
Ωö˙wY2MΩ`(ÙÁèxKı/É£˙ú˚÷ír($€‰E4“[Ö$k;ï}¨nŒzΩö˙wY2MΩ`(ÙÁèxK≈Ÿÿ°Ü‚»-	Ø™*o.sá>d˜,NÔgyjÑΩΩö˙wY2MΩ`(ÙÁèxKÏÑ∏Kle• ©æqÅñR0!b÷”<Hôúk)Z+
Ωö˙wY2MΩ`(ÙÁèxK√©öF§d†W√XmÉŒıÙÆ∑9yÌâ2t-ÌSfΩö˙wY2MΩ`(ÙÁèxKX˚îÔï¢YC≥˚_%†ﬂ?‰LX…^
∏á)uh´óqΩö˙wY2MΩ`(ÙÁèxKSë√¢˚!¶™‹%Æw·ü]o	Õ	Ó≤Pô"øÕYíÍΩö˙wY2MΩ`(ÙÁèxK÷&~jqã¡$´ç¢|ªe,†:{k%}ΩÀΩ`ˆ^Û—Ωö˙wY2MΩ`(ÙÁèxK–cÏ(ˆ~∫SÒd-ø}ˇ3∆£*›Üü`˛.,2ÒÀÂmΩö˙wY2MΩ`(ÙÁèxK)∆ÎR¥<:°ã,ÿÌn®`|Ô<˙·∫˛eu\ÚÊÑJDΩö˙wY2MΩ`(ÙÁèxKê˚Ái÷3@ç>h2€≤“	‡'%'ﬂ∂=I“ïr¶ÙLΩö˙wY2MΩ`(ÙÁèxKo¨ÍœÏ˝N0;tÙÄ†Äò‚–Ä+ìoé«tŒ!ÛÜhúΩö˙wY2MΩ`(ÙÁèxKN:[C∆¶ª”@O4=œ9bgŒî¯µ.#©⁄íΩö˙wY2MΩ`(ÙÁèxK+ôœ&B.í˛6_øK√'lû·KzoˇD˚/kêiô9Ωö˙wY2MΩ`(ÙÁèxK.pëgÜ¶˜sQß´pµW∆2.©#≤®”π+QØ}Ωö˙wY2MΩ`(ÙÁèxK?Œõüﬂ>ùTR∞˘^‰Å¬∑mt:syqUépjŒ>sΩö˙wY2MΩ`(ÙÁèxKGÃa'‚öÜ‡:kÔ,‘¯≈Zmk€6!h√,„*ZﬂΩö˙wY2MΩ`(ÙÁèxKqÚêo“"I~T£Fb´$ó¸» wıhÈ„ŸøÀ˝cuΩö˙wY2MΩ`(ÙÁèxKÇ€;Œ¥ˆCŒùó√—áÕõYAÕ=ËXo+⁄V7W_gΩö˙wY2MΩ`(ÙÁèxKä÷HYÒïµıçØ™îjag¨÷zànèFìdr!≈YEπΩö˙wY2MΩ`(ÙÁèxKçé¢âœÁ
´seÀ(ÓQÌ”<ÚPmËà˚≠÷øÄHΩö˙wY2MΩ`(ÙÁèxKÆÎÆ1Q'sÌï™.g9Ì1©Ög0:3"ò¯7	©’Z°Ωö˙wY2MΩ`(ÙÁèxKƒ	Ω¨Gu≠ÿ€í™"µ∑˚åî°F,È§π]ä3à¬¸Ωö˙wY2MΩ`(ÙÁèxK∆¡®±Ó*Å(µ®LÉ◊…ã['(aÎÊí¬ñΩö˙wY2MΩ`(ÙÁèxK…3f∏Á˘ÉóT…óÒsÎ&ÿ°π„Ωø∆g´€ãΩö˙wY2MΩ`(ÙÁèxKdW[Ÿxö.≠Vˆ4RØk¯˘D xYuÈN-d◊EΩö˙wY2MΩ`(ÙÁèxKE«»Æu
œªH¸7R}d›dMÆÿë<Õä$…MÖigﬂéΩö˙wY2MΩ`(ÙÁèxKÅÿ˚Lû.zÇ%ekKÇs∑À§∞>ÚÈÎ ‡†)$Ï°∫ÜΩö˙wY2MΩ`(ÙÁèxKπ*Úò‹õx«tí÷Uq◊*≠£◊{ÂF	‰2xÔnMΩö˙wY2MΩ`(ÙÁèxK·ùÆÉ¿.o(X‘Î—w#¥ıÍ5y’D=Ï≈˘<ùΩö˙wY2MΩ`(ÙÁèxK9€¬(éÙK_ï3,∑w„Ë@€¶ÄcJ®ı…± Ωö˙wY2MΩ`(ÙÁèxK2ıî¢ùÿ¢¡EÊ¸âdf(ˇÃ|zB Â3}ç)ƒΩΩö˙wY2MΩ`(ÙÁèxK‘_À£ñÆÛ>ËˆÏÆXØËGj(
 &¸qˆ!}œI∫/Ωö˙wY2MΩ`(ÙÁèxKKÜh•‘eº›ê ™ç¸ˇBOÀ–ÆŒ2¸p®>ë`Ëü	Ωö˙wY2MΩ`(ÙÁèxKâÛ—ˆ‰Ö√4Õù	ï„Õ˝¿q±ÑòTÑzD‹UH‚‹˚Ωö˙wY2MΩ`(ÙÁèxK…Ï5ÚnUöˇ¥‚ÎﬁT5L5©ò`[èœó-çUΩö˙wY2MΩ`(ÙÁèxK≥Â4økWÜó3ìü$∂k§e„^ë∞6**ÕÈpIΩö˙wY2MΩ`(ÙÁèxKücÌW√î¥.Ò
f±D¶[°∂Wù˘Ké≤ƒÕ`¡Ωö˙wY2MΩ`(ÙÁèxK›YØVD„åc˚‡Ö0†ÕwF*!íY∞[¬YÊsΩö˙wY2MΩ`(ÙÁèxK€Øûm=[8∂ÖS0JºàÇ~º ¯π«·óÕºX"Õ1lΩö˙wY2MΩ`(ÙÁèxKeÛ¿†Ñ”bπr.ò˜^^ôlnìO{+.kÊﬁ» ÏΩö˙wY2MΩ`(ÙÁèxK[$éë=qÖ==•Æ›çöK≈zëq&W8˚_À-Ü¢Ò»ÜΩö˙wY2MΩ`(ÙÁèxK&ye„AÚœ®ÉF5V™ØwßkçƒÑ…0tl˜µΩö˙wY2MΩ`(ÙÁèxKª—mS co##ß®o=ˇñüÑà¿WK¬◊á˛…?Ωö˙wY2MΩ`(ÙÁèxK‡! ˆ|~¯_NÌ6èøpí8
<# ë˝Cî∞Ωö˙wY2MΩ`(ÙÁèxKïüA7«ê∞“vqïÂosÄ}:‹¯ˆÁø-Mô0_âΩö˙wY2MΩ`(ÙÁèxKÊ!j Ôd@•UÏæŸ@±•ÚVöÌíïa7ÆXH.Ò∑Ωö˙wY2MΩ`(ÙÁèxKn˛˛[Gã{îL”®¨¢Ã§ àà‚üäÀX$◊∫∞Ωö˙wY2MΩ`(ÙÁèxKù ÆL‘zA«É‹HÛB¿v¬¡o4Ù“ﬂP—Å ;µ≠ÖùΩö˙wY2MΩ`(ÙÁèxKÿ‘Ê›ˆ‰-t¶•6Íb˝‰)\û\6ï£BÔµı§Ωö˙wY2MΩ`(ÙÁèxKÚwØOõ‹ëäËü£\¡≥N4òLÆóe2,<∞IWM6PúΩö˙wY2MΩ`(ÙÁèxK¬LuÎÔVπÒ:πﬁ`‚Ï°ƒQ 4‚êª≥lˆ
Tõ#LΩö˙wY2MΩ`(ÙÁèxKÉXÅÚ•W-pYµ»cPU(íÈEbo_… ¨˜ΩËW§Ωö˙wY2MΩ`(ÙÁèxK∫ﬂı‰˛ßp®˚"‰ƒ8!„!ı-Ot›PÒ–9ºΩö˙wY2MΩ`(ÙÁèxKƒR´Ñ`sﬂZŒ%Ã¶Mkz	Ÿ0äeÎR@„ƒÎ ©ÃΩö˙wY2MΩ`(ÙÁèxKÒÜ>»∑Ù?î≠˚ãJiIzåeÏº*U‡ªBw+å‹ëΩö˙wY2MΩ`(ÙÁèxK{…ÀTcŒµ^∏∫w—¨“Éƒ?JW`<¡Ú,Î≈yΩö˙wY2MΩ`(ÙÁèxKË 9]æWÅË Qx¥∫ı¢Wnë!¶|Y_j‚%˝Ωö˙wY2MΩ`(ÙÁèxK¥‹ Ú»œß¥ìéq˛+ñë‰!oŸT(g-l~sΩö˙wY2MΩ`(ÙÁèxK>Œ'À≥ÏD8ÃÂ#π'ƒ_‹\Y:7f€òL^Cz?ˆ°kΩö˙wY2MΩ`(ÙÁèxKhÓF2«æf»>â›ìÍÓîöøE¥¬«-}«Iö¢†CΩö˙wY2MΩ`(ÙÁèxK‚K1ZUqH=ãês≥-·M·Î.´!˝-ú1üı^–Ωö˙wY2MΩ`(ÙÁèxKÁ¬:¥ÅÏàUÏ•)7ÅÿKZ¬Oà&kRpÁÏ¥™%8Ωö˙wY2MΩ`(ÙÁèxK‹Ã<·¿‰∞±á”r†˙Gı¬oW£Yæ{'ÄN¨∫ƒΩö˙wY2MΩ`(ÙÁèxKWˇq*‰â≥tì¿vßÕ©a)ÿ®˝h“∂Øc91]Ωö˙wY2MΩ`(ÙÁèxK:ë˘Â(¢ôL}ì,^·LË·»0J‰ï≠≈åƒE<Ωö˙wY2MΩ`(ÙÁèxKIS ylõÚQ´•ù≥’~ù+Ö◊◊d4Ïu∫£ÖtÂΩö˙wY2MΩ`(ÙÁèxKÅ®≤…uÎ´ß€ﬁ^Èi¿ÍÓ*1√ãë®gV¶∑pΩö˙wY2MΩ`(ÙÁèxKéSÔ‹¯RŒÂ¶È)1ºBÊ<”ˆIÃßËrR√§YñΩö˙wY2MΩ`(ÙÁèxKô-5öß•˜â“hπLπHZkÊCb∞Ì¥DÃ|9d{Ωö˙wY2MΩ`(ÙÁèxKü§’?‘> ˇB ∫~çCS%ù+~^rµ	nˇÄ'÷mCΩö˙wY2MΩ`(ÙÁèxK”r¿–Ù˝…ı.û#¸VÓrAJÛP–Œ¶¬j5¶√!zΩö˙wY2MΩ`(ÙÁèxK\XjÖÈ7âEp‘˘Îh(π|AÀõ¶”‹Ã_RzUΩö˙wY2MΩ`(ÙÁèxKˆJ)îäàæˇ€^	ß7œŸŒkœéd!1è´áΩö˙wY2MΩ`(ÙÁèxKÿ~q4Tao[◊Ñöµ¡q*∏O4îxÏ*8˘p¿âΩö˙wY2MΩ`(ÙÁèxKÎ[≠“nOÆe˘§#XﬁÔ|Â,¿_ª«gvÊùò*Ωö˙wY2MΩ`(ÙÁèxKª"âÈÈM ˇ?bQj∞~óõ,lÔ‚´p∆ﬂ¡üç•Ωö˙wY2MΩ`(ÙÁèxK	(@ã˜%Êgÿq8®ÓºRñ-(GÒn5á;A∂≠Ωö˙wY2MΩ`(ÙÁèxK	˘ä©Öås¯õß~áÏoYlIP˚èã∫Ä¶/ªëKΩö˙wY2MΩ`(ÙÁèxK
uÍpÍ§”Ût$mµO«¥>Yj53	π√kOŸur^Ωö˙wY2MΩ`(ÙÁèxKQ◊êoƒìIv]®ÜÇBk,˛ûj§ÚrSÍ¥ 2„ßΩö˙wY2MΩ`(ÙÁèxK£¢ö–Q0◊˛[Ù“YecÕÌá@ñ™Ãiì*.IQöΩö˙wY2MΩ`(ÙÁèxKw0¥/˛I?È∂%óÕ+o4”jıì0Ò§/îΩö˙wY2MΩ`(ÙÁèxKè·èqZüœ·§DŒˇÖÜû¥"3¿K1L)]mßûΩö˙wY2MΩ`(ÙÁèxKêë®‘sÂ(®x#ΩbÊUﬂÆT˙+˙r˝¿)Ü÷∏Ωö˙wY2MΩ`(ÙÁèxKãX¡˝∏⁄ã3ÃÓ_ó:˜4ŸÛ„?]±W<+†à®Ωö˙wY2MΩ`(ÙÁèxKëÜÔﬂ^ÚﬁÇE∫ÆÅ4ÜÜ∫5ˇ=òe¡S|ÌìΩö˙wY2MΩ`(ÙÁèxK'Ñ≤ùÜÒc∞j™‰Î∏ﬂ¯ﬁ}Ç[à9ˇf'NˇGΩö˙wY2MΩ`(ÙÁèxK)Ã§TN£0÷ë«Ñi\úk "¨{[âÀ◊( —@ÍΩö˙wY2MΩ`(ÙÁèxK+"òÍ¢kùƒ§UäÈ.{∞‰¯\ÛK¯H˝ˆ6¿¡æƒòóΩö˙wY2MΩ`(ÙÁèxK-œéçÅp#—Ë·E=h÷Ï0ŸæŸLº∏›¡Ã¨Ωö˙wY2MΩ`(ÙÁèxK1*≈[P¿õ0≥Ãìπî°>Ó¨TÔâ/ƒGªΩñ°Ωö˙wY2MΩ`(ÙÁèxK2≠2ñÇõƒmœ¨^›Àùø,Ì\¯;"œún`«ò‘ßΩö˙wY2MΩ`(ÙÁèxK4£+X3é+VØ0©ﬂ÷π“'‡‚£IX±∆%ûÖΩö˙wY2MΩ`(ÙÁèxK6.” ±‡í(1©o

œﬁaâSÊï…Ô.∞∫√uPΩö˙wY2MΩ`(ÙÁèxK6z1ÂÉà1≠,FGàjlﬂÚÊ±∫ëˇÖ‹záÆõ^òΩö˙wY2MΩ`(ÙÁèxK7e◊i¿[˘ãB{5ê;!7Ë§õoÖù
ÒYÌjÜxj¶4Ωö˙wY2MΩ`(ÙÁèxK8mi\ﬂ-Ev‡ Ãı‰ûx⁄QØôU¿∏˙v7; yî≥Ωö˙wY2MΩ`(ÙÁèxK:OtæØÆ+ìÉ≠Ç“3¶œ=≥«‚ËóæÔBU˙ÓùΩö˙wY2MΩ`(ÙÁèxK:ÁlE pÈYòBb-“Qº°˚Êπ≈.¡s∞5Ωö˙wY2MΩ`(ÙÁèxK;ËÁÎ4ç5¡íè«iÑgàôA—ˆœ	QL°iìOsYΩö˙wY2MΩ`(ÙÁèxK>9&∏°Z’°AgªdzÑ<=C!„]ºD‹Ë»7A-(∞Ωö˙wY2MΩ`(ÙÁèxK@
∆mY∑∞î©„¶Ω:ˇ0WÉÁY/Bæ_Ù∫èΩö˙wY2MΩ`(ÙÁèxKAÖÇm´[®4{x¢+_ö
up \ìßMGäy=É∫ƒòΩö˙wY2MΩ`(ÙÁèxKA—Ó±w¿2N›eWÛÑÂ2ﬁıöDkÔ≥Qº%ùwΩö˙wY2MΩ`(ÙÁèxKEákMÿa‘[:îÄtz]¥ZH≤ß)A	∂A/äáÈ]Ωö˙wY2MΩ`(ÙÁèxKFgø%◊¡†kÑt∆Õ±ﬂdäXsoøW–]ou]´gÙΩö˙wY2MΩ`(ÙÁèxKGˇc±@∂¸Ìy1ÊQ⁄[./]ÆÙ=¬˚≈2±Ωö˙wY2MΩ`(ÙÁèxKWÊë:˙ÃR"ΩvÕØ1¯ÌàâTd%StÔ	zÇ◊ıö”ïñΩö˙wY2MΩ`(ÙÁèxKXê˙"q!«mêÌûc»~:e3Ó†ˆ°¢?ƒEõ∆ºﬂΩö˙wY2MΩ`(ÙÁèxK]öÀªJ}KhRﬂYp‚Œ÷oˆ"Óú–ÌÿAÃ≠Ωö˙wY2MΩ`(ÙÁèxKaŒƒ£wøY¿˛Æ„p4øó’ºn‚:ﬂ∫Ê„ı˚<˝Ωö˙wY2MΩ`(ÙÁèxKcW¥E6,ê∆òKƒ∂(‚=æ$∂Èlä„‹∞’¨Ωö˙wY2MΩ`(ÙÁèxKe≤ÁÃŸ√1ﬂRﬂs …2“üôtÅ≈o0á≤›1GΩö˙wY2MΩ`(ÙÁèxKf™†Ì¬8MúB]9'ÊÌJ]@≈ÁÕM¨àıwÚÒΩö˙wY2MΩ`(ÙÁèxKhs“ˆ)ΩRÈTÓˇYw™ÉgCôóÅbˇ!,îÅ3∆çóΩö˙wY2MΩ`(ÙÁèxKmªÍ“>åÜ¯¥t˚¸• M„‚ãàªÃ‹GGìNΩö˙wY2MΩ`(ÙÁèxKmÍ—2Wﬂ√Ã∆§≥p∫ëu_È‡ÏAP0î.ZºG|àΩö˙wY2MΩ`(ÙÁèxKp°E
Ú≠9Ui≠
˛±Ÿ¡%