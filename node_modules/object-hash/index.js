'use strict';

var crypto = require('crypto');

/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` {true|*false} hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` {true|*false} ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param {object} object value to hash
 * @param {object} options hashing options
 * @return {string} hash value
 * @api public
 */
exports = module.exports = objectHash;

function objectHash(object, options){
  options = applyDefaults(object, options);

  return hash(object, options);
}

/**
 * Exported sugar methods
 *
 * @param {object} object value to hash
 * @return {string} hash value
 * @api public
 */
exports.sha1 = function(object){
  return objectHash(object);
};
exports.keys = function(object){
  return objectHash(object, {excludeValues: true, algorithm: 'sha1', encoding: 'hex'});
};
exports.MD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex'});
};
exports.keysMD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex', excludeValues: true});
};

// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];
hashes.push('passthrough');
var encodings = ['buffer', 'hex', 'binary', 'base64'];

function applyDefaults(object, sourceOptions){
  sourceOptions = sourceOptions || {};

  // create a copy rather than mutating
  var options = {};
  options.algorithm = sourceOptions.algorithm || 'sha1';
  options.encoding = sourceOptions.encoding || 'hex';
  options.excludeValues = sourceOptions.excludeValues ? true : false;
  options.algorithm = options.algorithm.toLowerCase();
  options.encoding = options.encoding.toLowerCase();
  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
  options.respectType = sourceOptions.respectType === false ? false : true; // default to true
  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
  options.replacer = sourceOptions.replacer || undefined;
  options.excludeKeys = sourceOptions.excludeKeys || undefined;

  if(typeof object === 'undefined') {
    throw new Error('Object argument required.');
  }

  // if there is a case-insensitive match in the hashes list, accept it
  // (i.e. SHA256 for sha256)
  for (var i = 0; i < hashes.length; ++i) {
    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
      options.algorithm = hashes[i];
    }
  }

  if(hashes.indexOf(options.algorithm) === -1){
    throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' +
      'supported values: ' + hashes.join(', '));
  }

  if(encodings.indexOf(options.encoding) === -1 &&
     options.algorithm !== 'passthrough'){
    throw new Error('Encoding "' + options.encoding + '"  not supported. ' +
      'supported values: ' + encodings.join(', '));
  }

  return options;
}

/** Check if the given function is a native function */
function isNativeFunction(f) {
  if ((typeof f) !== 'function') {
    return false;
  }
  var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
  return exp.exec(Function.prototype.toString.call(f)) != null;
}

function hash(object, options) {
  var hashingStream;

  if (options.algorithm !== 'passthrough') {
    hashingStream = crypto.createHash(options.algorithm);
  } else {
    hashingStream = new PassThrough();
  }

  if (typeof hashingStream.write === 'undefined') {
    hashingStream.write = hashingStream.update;
    hashingStream.end   = hashingStream.update;
  }

  var hasher = typeHasher(options, hashingStream);
  hasher.dispatch(object);
  if (!hashingStream.update) {
    hashingStream.end('');
  }

  if (hashingStream.digest) {
    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);
  }

  var buf = hashingStream.read();
  if (options.encoding === 'buffer') {
    return buf;
  }

  return buf.toString(options.encoding);
}

/**
 * Expose streaming API
 *
 * @param {object} object  Value to serialize
 * @param {object} options  Options, as for hash()
 * @param {object} stream  A stream to write the serializiation to
 * @api public
 */
exports.writeToStream = function(object, options, stream) {
  if (typeof stream === 'undefined') {
    stream = options;
    options = {};
  }

  options = applyDefaults(object, options);

  return typeHasher(options, stream).dispatch(object);
};

function typeHasher(options, writeTo, context){
  context = context || [];
  var write = function(str) {
    if (writeTo.update) {
      return writeTo.update(str, 'utf8');
    } else {
      return writeTo.write(str, 'utf8');
    }
  };

  return {
    dispatch: function(value){
      if (options.replacer) {
        value = options.replacer(value);
      }

      var type = typeof value;
      if (value === null) {
        type = 'null';
      }

      //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

      return this['_' + type](value);
    },
    _object: function(object) {
      var pattern = (/\[object (.*)\]/i);
      var objString = Object.prototype.toString.call(object);
      var objType = pattern.exec(objString);
      if (!objType) { // object type did not match [object ...]
        objType = 'unknown:[' + objString + ']';
      } else {
        objType = objType[1]; // take only the class name
      }

      objType = objType.toLowerCase();

      var objectNumber = null;

      if ((objectNumber = context.indexOf(object)) >= 0) {
        return this.dispatch('[CIRCULAR:' + objectNumber + ']');
      } else {
        context.push(object);
      }

      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write('buffer:');
        return write(object);
      }

      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') {
        if(this['_' + objType]) {
          this['_' + objType](object);
        } else if (options.ignoreUnknown) {
          return write('[' + objType + ']');
        } else {
          throw new Error('Unknown object type "' + objType + '"');
        }
      }else{
        var keys = Object.keys(object);
        if (options.unorderedObjects) {
          keys = keys.sort();
        }
        // Make sure to incorporate special properties, so
        // Types with different prototypes will produce
        // a different hash and objects derived from
        // different functions (`new Foo`, `new Bar`) will
        // produce different hashes.
        // We never do this for native functions since some
        // seem to break because of that.
        if (options.respectType !== false && !isNativeFunction(object)) {
          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');
        }

        if (options.excludeKeys) {
          keys = keys.filter(function(key) { return !options.excludeKeys(key); });
        }

        write('object:' + keys.length + ':');
        var self = this;
        return keys.forEach(function(key){
          self.dispatch(key);
          write(':');
          if(!options.excludeValues) {
            self.dispatch(object[key]);
          }
          write(',');
        });
      }
    },
    _array: function(arr, unordered){
      unordered = typeof unordered !== 'undefined' ? unordered :
        options.unorderedArrays !== false; // default to options.unorderedArrays

      var self = this;
      write('array:' + arr.length + ':');
      if (!unordered || arr.length <= 1) {
        return arr.forEach(function(entry) {
          return self.dispatch(entry);
        });
      }

      // the unordered case is a little more complicated:
      // since there is no canonical ordering on objects,
      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
      // we first serialize each entry using a PassThrough stream
      // before sorting.
      // also: we canâ€™t use the same context array for all entries
      // since the order of hashing should *not* matter. instead,
      // we keep track of the additions to a copy of the context array
      // and add all of them to the global context array when weâ€™re done
      var contextAdditions = [];
      var entries = arr.map(function(entry) {
        var strm = new PassThrough();
        var localContext = context.slice(); // make copy
        var hasher = typeHasher(options, strm, localContext);
        hasher.dispatch(entry);
        // take only what was added to localContext and append it to contextAdditions
        contextAdditions = contextAdditions.concat(localContext.slice(context.length));
        return strm.read().toString();
      });
      context = context.concat(contextAdditions);
      entries.sort();
      return this._array(entries, false);
    },
    _date: function(date){
      return write('date:' + date.toJSON());
    },
    _symbol: function(sym){
      return write('symbol:' + sym.toString());
    },
    _error: function(err){
      return write('error:' + err.toString());
    },
    _boolean: function(bool){
      return write('bool:' + bool.toString());
    },
    _string: function(string){
      write('string:' + string.length + ':');
      write(string.toString());
    },
    _function: function(fn){
      write('fn:');
      if (isNativeFunction(fn)) {
        this.dispatch('[native]');
      } else {
        this.dispatch(fn.toString());
      }

      if (options.respectFunctionNames !== false) {
        // Make sure we can still distinguish native functions
        // by their name, otherwise String and Function will
        // have the same hash
        this.dispatch("function-name:" + String(fn.name));
      }

      if (options.respectFunctionProperties) {
        this._object(fn);
      }
    },
    _number: function(number){
      return write('number:' + number.toString());
    },
    _xml: function(xml){
      return write('xml:' + xml.toString());
    },
    _null: function() {
      return write('Null');
    },
    _undefined: function() {
      return write('Undefined');
    },
    _regexp: function(regex){
      return write('regex:' + regex.toString());
    },
    _uint8array: function(arr){
      write('uint8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint8clampedarray: function(arr){
      write('uint8clampedarray:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int8array: function(arr){
      write('int8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint16array: function(arr){
      write('uint16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int16array: function(arr){
      write('int16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint32array: function(arr){
      write('uint32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int32array: function(arr){
      write('int32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float32array: function(arr){
      write('float32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float64array: fuuÿuÿuèÃÿÿÿ‹ğ…öx1jj ÿuüÿ‹È…Éuÿ€‹ğ…ö~·öÎ  €ë‹E3ö‰ƒ}ü tÿ¸€ÿuüj Pÿl€‹Æ^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì¡$r3Å‰EüV‹uUô3À‰Mè‰Eì‰Eğ‰‹EW‰EôEğPjYÇEøY è‘öÿÿ‹ø…ÿx7‹MèEìPÿuğèU  ‹ø…ÿx‹Eì3É‰3ÿë‹Mì…Ét‹Q‹p‹ÎÿT‚ÿÖƒ}ğ tÿ¸€ÿuğj Pÿl€‹Mü‹Ç_3Í^è)  ÉÂ ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìV‹u3ÒW‹Á‰UøMü‰EôQRRRh8Y ÿu‹È‰Rÿu‰UüèZûÿÿ‹ø…ÿx7‹MôEøPÿuüè¯  ‹ø…ÿx‹Eø3É‰3ÿë‹Mø…Ét‹Q‹p‹ÎÿT‚ÿÖƒ}ü tÿ¸€ÿuüj Pÿl€‹Ç_^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì¡$r3Å‰EüSV‹ñ3Û‰]ğ9^tW‹~…ÿtÿv‹ÏÿT‚ÿ×‰^_9^tÿvèkÿÿ‰^‹F…Àt7‰EôUôEğÇEøX PjYèõÿÿ…Àuÿuğÿ<€ÿvÿ@€Nè   ‹Mü^3Í[èÍ'  ÉÃ‹ÿV‹ñƒ> tÿ6d¡0   j ÿpÿ ‚…ÀujYÍ)ƒ& ^Ã‹ÿW‹ù‹…Òt‹VR‹p‹ÎÿT‚ÿÖƒ' ^_Ã‹ÿU‹ìVW3ÿ‹ò…Òtf99tƒÁƒêuó‹M‹Â÷ØÀ%©ÿøW €…Ét…Òt+ò‰1ë‰9_^]Â ÌÌÌÌÌÌÌÌÌÂ  ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿğÿ`xÃÌÌÌÌÌÌ‹ÿğÿ`xÃ‹ÿU‹ìƒì¡$r3Å‰Eü‹ES‹Ù‹MVW3ÿ‰Mğ‰}ô‰}ø9{…ˆ   jWPÿ9{tÌ‰C…Àu+ÿ€‹ø…ÿ~	·ÿÏ  €ÿ~ €…Ô   ¿@ €éÊ   hPY Pÿ¬€‰C(…Àuÿ€‹ø…ÿ§   ·ÿÏ  €é™   hdY ÿsÿ¬€‰C,…ÀtÍs09>uOEôPjÿH‚‹ø…ÿxkƒ> ‹{(tÌVhğ.hğ.h/h /hğ.h‘ ÿuô‹ÏÿT‚ÿ×‹ø…ÿx03ÿ‹‹‹pEøPhtY WQ‹ÎÿT‚ÿÖ‹ø…ÿx‹Mğ‹Eøƒeø ‰‹Mø…Ét‹Q‹p‹ÎÿT‚ÿÖ‹Mô…Ét‹Q‹p‹ÎÿT‚ÿÖ…ÿyƒ{ t3ö9s0uÿsèÓ~ÿÿ‰s‰s(‰s,‹Mü‹Ç_^3Í[èj%  ÉÂ ÌÌÌÌÌÌ‹ÿU‹ìì  ¡$r3Å‰Eü‹ES‹]V3ö‰ìıÿÿ‰µğıÿÿW…Àt"f90tPº  ôıÿÿèf5ÿÿ‹ø…ÿˆ±   ëj.Xf‰…ôıÿÿ3Àf‰…öıÿÿôıÿÿQf‹ƒÁf;Æuõ+ÊÑùfƒ¼Mòıÿÿ\uMşÿÿÿù  s}3Àf‰„ôıÿÿhY º  ôıÿÿè+5ÿÿ‹ø…ÿxE‹ìıÿÿ…ğıÿÿP…ôıÿÿPè…ıÿÿ‹ø…ÿx‹…ğıÿÿ‹ş‰ë‹µğıÿÿ…öt‹V‹p‹ÎÿT‚ÿÖ‹Mü‹Ç_^3Í[èP$  ÉÂ è%  ÌÌÌÌÌÌÌ‹ÿV‹ñW‹~,…ÿt‹ÏÿT‚ÿ×ƒf, ‹Îè¾ûÿÿN0èvüÿÿƒ~ tÿvèY}ÿÿƒf _^ÃÌ‹ÿV‹ñW‹~,…ÿt‹ÏÿT‚ÿ×ƒf, N0è=üÿÿƒ~ tÿvè }ÿÿƒf _^Ã‹ÿU‹ìƒìh¡$r3Å‰Eø‹ES‹ÙV3ö‰]àW93t3Àé1  VVP‰wÿ‹ø…ÿu*ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìM   ét  9stÌhĞY Wÿ¬€‰EØ…Àu5hèY ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEì^   é&  9stÌhZ Wÿ¬€‰EÔ…Àu5h0Z ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEì_   éØ  9stÌh`Z Wÿ¬€‰EĞ…Àu5htZ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEì`   éŠ  9stÌh Z Wÿ¬€‰EÌ…Àu5h¸Z ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìa   é<  9stÌhèZ Wÿ¬€‰EÈ…Àu5h[ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìb   éî  9s tÌh8[ Wÿ¬€‰EÄ…Àu5hL[ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìc   é   9s$tÌh\O Wÿ¬€‰EÀ…Àu5hx[ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìd   éR  9s(tÌh¨[ Wÿ¬€‰E¼…Àu5h¸[ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìe   é  9s,tÌhà[ Wÿ¬€‰E¸…Àu5hü[ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìf   é¶  9s0tÌhÄO Wÿ¬€‰E´…Àu5h0\ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìg   éh  9s4tÌhX\ Wÿ¬€‰E°…Àu5hh\ ÿH€ÿ€…Àu»ı6  ëÿ€‹Ø…ÛuÌÇEìh   é  9s8tÌhP Wÿ¬€‰EÜ…Àu5h\ ÿH€ÿ€…Àu